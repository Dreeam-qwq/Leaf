From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Fri, 14 Feb 2025 23:29:17 +0100
Subject: [PATCH] Optimize getEntities


diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
index b6af8da084c83ee38bb3ecea6a98feb0c1c74d2a..18bf246943a831e4c5bc9697e445c147c778b0fd 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
@@ -17,8 +17,6 @@ import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntitySpawnReason;
 import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.boss.EnderDragonPart;
-import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.chunk.storage.EntityStorage;
@@ -28,6 +26,7 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
+import java.util.function.Consumer;
 import java.util.function.Predicate;
 
 public final class ChunkEntitySlices {
@@ -42,7 +41,7 @@ public final class ChunkEntitySlices {
     private final EntityCollectionBySection hardCollidingEntities;
     private final Reference2ObjectOpenHashMap<Class<? extends Entity>, EntityCollectionBySection> entitiesByClass;
     private final Reference2ObjectOpenHashMap<EntityType<?>, EntityCollectionBySection> entitiesByType;
-    private final EntityList entities = new EntityList();
+    public final EntityList entities = new EntityList();
 
     public FullChunkStatus status;
     public final ChunkData chunkData;
@@ -465,6 +464,7 @@ public final class ChunkEntitySlices {
             this.entitiesBySection = new BasicEntityList[sectionCount];
         }
 
+
         public void addEntity(final Entity entity, final int sectionIndex) {
             BasicEntityList<Entity> list = this.entitiesBySection[sectionIndex];
 
diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
index 7554c109c35397bc1a43dd80e87764fd78645bbf..07d8a7e2ba312efd8be0692141e69e6b86240ce5 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
@@ -560,45 +560,158 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
         return slices;
     }
 
-    public void getEntities(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
-        final int minChunkX = (Mth.floor(box.minX) - 2) >> 4;
-        final int minChunkZ = (Mth.floor(box.minZ) - 2) >> 4;
-        final int maxChunkX = (Mth.floor(box.maxX) + 2) >> 4;
-        final int maxChunkZ = (Mth.floor(box.maxZ) + 2) >> 4;
+    public final class EntityPool {
+        private static final int INITIAL_SIZE = 1024;
+        private static final Entity[] POOL = new Entity[INITIAL_SIZE];
+        private static int size = 0;
+
+        public static void clear() {
+            // Clear references to help GC
+            for (int i = 0; i < size; i++) {
+                POOL[i] = null;
+            }
+            size = 0;
+        }
+
+        public static void add(Entity entity) {
+            if (size >= POOL.length) {
+                // Pool is full, double it
+                Entity[] newPool = new Entity[POOL.length * 2];
+                System.arraycopy(POOL, 0, newPool, 0, POOL.length);
+                newPool[size++] = entity;
+                System.arraycopy(newPool, 0, POOL, 0, newPool.length);
+            } else {
+                POOL[size++] = entity;
+            }
+        }
+
+        public static void transferTo(List<Entity> target) {
+            // Bulk transfer to target list
+            if (target instanceof ArrayList) {
+                ArrayList<Entity> arrayList = (ArrayList<Entity>)target;
+                arrayList.ensureCapacity(arrayList.size() + size);
+            }
+            for (int i = 0; i < size; i++) {
+                target.add(POOL[i]);
+            }
+            clear();
+        }
+    }
 
+    public void getEntities(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
+        // Cache box calculations
+        final double boxMinX = box.minX - 2.0;
+        final double boxMaxX = box.maxX + 2.0;
+        final double boxMinZ = box.minZ - 2.0;
+        final double boxMaxZ = box.maxZ + 2.0;
+        final double boxMinY = box.minY - 2.0;
+        final double boxMaxY = box.maxY + 2.0;
+
+        // Pre-calculate all bounds at once
+        final int minChunkX = Mth.floor(boxMinX) >> 4;
+        final int maxChunkX = Mth.floor(boxMaxX) >> 4;
+        final int minChunkZ = Mth.floor(boxMinZ) >> 4;
+        final int maxChunkZ = Mth.floor(boxMaxZ) >> 4;
+        final int minSectionY = Mth.floor(boxMinY) >> 4;
+        final int maxSectionY = Mth.floor(boxMaxY) >> 4;
+
+        // Pre-calculate region bounds
         final int minRegionX = minChunkX >> REGION_SHIFT;
-        final int minRegionZ = minChunkZ >> REGION_SHIFT;
         final int maxRegionX = maxChunkX >> REGION_SHIFT;
+        final int minRegionZ = minChunkZ >> REGION_SHIFT;
         final int maxRegionZ = maxChunkZ >> REGION_SHIFT;
 
-        for (int currRegionZ = minRegionZ; currRegionZ <= maxRegionZ; ++currRegionZ) {
-            final int minZ = currRegionZ == minRegionZ ? minChunkZ & REGION_MASK : 0;
-            final int maxZ = currRegionZ == maxRegionZ ? maxChunkZ & REGION_MASK : REGION_MASK;
-
-            for (int currRegionX = minRegionX; currRegionX <= maxRegionX; ++currRegionX) {
-                final ChunkSlicesRegion region = this.getRegion(currRegionX, currRegionZ);
+        // Early exit for empty regions
+        if (minRegionX > maxRegionX || minRegionZ > maxRegionZ) {
+            return;
+        }
 
-                if (region == null) {
-                    continue;
-                }
+        // Optimize ArrayList growth
+        if (into instanceof ArrayList) {
+            ArrayList<Entity> arrayList = (ArrayList<Entity>)into;
+            if (arrayList.isEmpty()) {
+                final int totalChunks = (maxChunkX - minChunkX + 1) * (maxChunkZ - minChunkZ + 1);
+                final int height = (maxSectionY - minSectionY + 1);
+                final double avgDensity = 2.0; // Average entities per vertical section
+                final int estimatedCapacity = Math.min((int)(totalChunks * height * avgDensity), 512);
+                arrayList.ensureCapacity(estimatedCapacity);
+            }
+        }
 
-                final int minX = currRegionX == minRegionX ? minChunkX & REGION_MASK : 0;
-                final int maxX = currRegionX == maxRegionX ? maxChunkX & REGION_MASK : REGION_MASK;
+        // Cache region lookup keys
+        final int regionsX = maxRegionX - minRegionX + 1;
+        final int regionsZ = maxRegionZ - minRegionZ + 1;
+        final long[] regionKeys = new long[regionsX * regionsZ];
+        int keyIndex = 0;
+        for (int rz = minRegionZ; rz <= maxRegionZ; ++rz) {
+            for (int rx = minRegionX; rx <= maxRegionX; ++rx) {
+                regionKeys[keyIndex++] = CoordinateUtils.getChunkKey(rx, rz);
+            }
+        }
 
-                for (int currZ = minZ; currZ <= maxZ; ++currZ) {
-                    for (int currX = minX; currX <= maxX; ++currX) {
-                        final ChunkEntitySlices chunk = region.get(currX | (currZ << REGION_SHIFT));
+        // Pre-calculate masks for chunk coordinates
+        final int minXMask = minChunkX & REGION_MASK;
+        final int maxXMask = maxChunkX & REGION_MASK;
+        final int minZMask = minChunkZ & REGION_MASK;
+        final int maxZMask = maxChunkZ & REGION_MASK;
+
+        // Process regions using cached keys
+        keyIndex = 0;
+        for (int rz = minRegionZ; rz <= maxRegionZ; ++rz) {
+            final int minZ = rz == minRegionZ ? minZMask : 0;
+            final int maxZ = rz == maxRegionZ ? maxZMask : REGION_MASK;
+
+            for (int rx = minRegionX; rx <= maxRegionX; ++rx) {
+                final ChunkSlicesRegion region = this.regions.get(regionKeys[keyIndex++]);
+                if (region == null) continue;
+
+                final int minX = rx == minRegionX ? minXMask : 0;
+                final int maxX = rx == maxRegionX ? maxXMask : REGION_MASK;
+
+                // Process chunks
+                for (int z = minZ; z <= maxZ; ++z) {
+                    final int zShift = z << REGION_SHIFT;
+                    for (int x = minX; x <= maxX; ++x) {
+                        final ChunkEntitySlices chunk = region.get(x | zShift);
                         if (chunk == null || !chunk.status.isOrAfter(FullChunkStatus.FULL)) {
                             continue;
                         }
 
-                        chunk.getEntities(except, box, into, predicate);
+                        // Process entities with cached bounds checking
+                        final Entity[] entities = chunk.entities.getRawData();
+                        final int size = chunk.entities.size();
+
+                        for (int i = 0; i < size; ++i) {
+                            final Entity entity = entities[i];
+                            if (entity == except) continue;
+
+                            if (checkEntityInBounds(entity, minSectionY, maxSectionY, box)) {
+                                if (predicate == null || predicate.test(entity)) {
+                                    into.add(entity);
+                                }
+                            }
+                        }
                     }
                 }
             }
         }
     }
 
+    private static boolean checkEntityInBounds(Entity entity, int minSectionY, int maxSectionY, AABB box) {
+        final AABB entityBox = entity.getBoundingBox();
+        if (entityBox == null) return false;
+
+        // Check Y bounds first as it's usually the quickest reject
+        final int entityMinY = Mth.floor(entityBox.minY) >> 4;
+        if (entityMinY > maxSectionY) return false;
+
+        final int entityMaxY = Mth.floor(entityBox.maxY) >> 4;
+        if (entityMaxY < minSectionY) return false;
+
+        // Only do full intersection test if Y bounds pass
+        return entityBox.intersects(box);
+    }
+
     public void getHardCollidingEntities(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
         final int minChunkX = (Mth.floor(box.minX) - 2) >> 4;
         final int minChunkZ = (Mth.floor(box.minZ) - 2) >> 4;
