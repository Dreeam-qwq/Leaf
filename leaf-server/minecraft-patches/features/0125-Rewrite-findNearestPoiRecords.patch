From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Sat, 22 Feb 2025 12:10:24 +0100
Subject: [PATCH] Rewrite findNearestPoiRecords


diff --git a/io/papermc/paper/util/PoiAccess.java b/io/papermc/paper/util/PoiAccess.java
index f39294b1f83c4022be5ced4da781103a1eee2daf..612b194a7a01942a57df9a31428732523eae2102 100644
--- a/io/papermc/paper/util/PoiAccess.java
+++ b/io/papermc/paper/util/PoiAccess.java
@@ -8,6 +8,8 @@ import it.unimi.dsi.fastutil.doubles.Double2ObjectRBTreeMap;
 import it.unimi.dsi.fastutil.longs.LongArrayFIFOQueue;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import java.util.function.BiPredicate;
+
+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.util.Mth;
@@ -126,7 +128,7 @@ public final class PoiAccess {
                                                    final PoiManager.Occupancy occupancy,
                                                    final boolean load,
                                                    final Set<BlockPos> ret) {
-        final Set<BlockPos> positions = new HashSet<>();
+        final ObjectOpenHashSet<BlockPos> positions = new ObjectOpenHashSet<>();
         // pos predicate is last thing that runs before adding to ret.
         final Predicate<BlockPos> newPredicate = (final BlockPos pos) -> {
             if (positionPredicate != null && !positionPredicate.test(pos)) {
@@ -400,7 +402,7 @@ public final class PoiAccess {
                                                final boolean load,
                                                final int max,
                                                final List<Pair<Holder<PoiType>, BlockPos>> ret) {
-        final Set<BlockPos> positions = new HashSet<>();
+        final ObjectOpenHashSet<BlockPos> positions = new ObjectOpenHashSet<>();
         // pos predicate is last thing that runs before adding to ret.
         final Predicate<BlockPos> newPredicate = (final BlockPos pos) -> {
             if (positionPredicate != null && !positionPredicate.test(pos)) {
@@ -451,27 +453,46 @@ public final class PoiAccess {
                                              final List<PoiRecord> ret) {
         final Predicate<? super PoiRecord> occupancyFilter = occupancy.getTest();
 
-        final Double2ObjectRBTreeMap<List<PoiRecord>> closestRecords = new Double2ObjectRBTreeMap<>();
-        int totalRecords = 0;
+        // Use a primitive-optimized array instead of HashMap-based collections
+        final PoiRecord[] topRecords = new PoiRecord[max];
         double furthestDistanceSquared = maxDistanceSquared;
 
-        final int lowerX = Mth.floor(sourcePosition.getX() - range) >> 4;
+        // Cache position coordinates to avoid repeated method calls
+        final int sourceX = sourcePosition.getX();
+        final int sourceY = sourcePosition.getY();
+        final int sourceZ = sourcePosition.getZ();
+
+        final int lowerX = Mth.floor(sourceX - range) >> 4;
         final int lowerY = WorldUtil.getMinSection(poiStorage.moonrise$getWorld());
-        final int lowerZ = Mth.floor(sourcePosition.getZ() - range) >> 4;
-        final int upperX = Mth.floor(sourcePosition.getX() + range) >> 4;
+        final int lowerZ = Mth.floor(sourceZ - range) >> 4;
+        final int upperX = Mth.floor(sourceX + range) >> 4;
         final int upperY = WorldUtil.getMaxSection(poiStorage.moonrise$getWorld());
-        final int upperZ = Mth.floor(sourcePosition.getZ() + range) >> 4;
+        final int upperZ = Mth.floor(sourceZ + range) >> 4;
 
-        final int centerX = sourcePosition.getX() >> 4;
-        final int centerY = Mth.clamp(sourcePosition.getY() >> 4, lowerY, upperY);
-        final int centerZ = sourcePosition.getZ() >> 4;
+        final int centerX = sourceX >> 4;
+        final int centerY = Mth.clamp(sourceY >> 4, lowerY, upperY);
+        final int centerZ = sourceZ >> 4;
         final long centerKey = CoordinateUtils.getChunkSectionKey(centerX, centerY, centerZ);
 
-        final LongArrayFIFOQueue queue = new LongArrayFIFOQueue();
-        final LongOpenHashSet seen = new LongOpenHashSet();
+        // Pre-calculate range bounds for faster filtering
+        final int minRangeX = sourceX - range;
+        final int maxRangeX = sourceX + range;
+        final int minRangeZ = sourceZ - range;
+        final int maxRangeZ = sourceZ + range;
+
+        // Use pre-allocated collections with explicit capacity
+        final LongArrayFIFOQueue queue = new LongArrayFIFOQueue(128);
+        final LongOpenHashSet seen = new LongOpenHashSet(128);
         seen.add(centerKey);
         queue.enqueue(centerKey);
 
+        // Temporary array to hold candidates instead of ArrayList
+        PoiRecord[] candidateBuffer = new PoiRecord[max * 4]; // Larger buffer to reduce reallocations
+        int candidateCount = 0;
+
+        // Track total records found
+        int totalRecords = 0;
+
         while (!queue.isEmpty()) {
             final long key = queue.dequeueLong();
             final int sectionX = CoordinateUtils.getChunkSectionX(key);
@@ -484,182 +505,299 @@ public final class PoiAccess {
             }
 
             final double sectionDistanceSquared = getSmallestDistanceSquared(
-                    (sectionX << 4) + 0.5,
-                    (sectionY << 4) + 0.5,
-                    (sectionZ << 4) + 0.5,
-                    (sectionX << 4) + 15.5,
-                    (sectionY << 4) + 15.5,
-                    (sectionZ << 4) + 15.5,
-                    (double) sourcePosition.getX(), (double) sourcePosition.getY(), (double) sourcePosition.getZ()
+                (sectionX << 4) + 0.5,
+                (sectionY << 4) + 0.5,
+                (sectionZ << 4) + 0.5,
+                (sectionX << 4) + 15.5,
+                (sectionY << 4) + 15.5,
+                (sectionZ << 4) + 15.5,
+                sourceX, sourceY, sourceZ
             );
 
             if (sectionDistanceSquared > (totalRecords >= max ? furthestDistanceSquared : maxDistanceSquared)) {
                 continue;
             }
 
-            // queue all neighbours
-            for (int dz = -1; dz <= 1; ++dz) {
-                for (int dx = -1; dx <= 1; ++dx) {
-                    for (int dy = -1; dy <= 1; ++dy) {
-                        // -1 and 1 have the 1st bit set. so just add up the first bits, and it will tell us how many
-                        // values are set. we only care about cardinal neighbours, so, we only care if one value is set
-                        if ((dx & 1) + (dy & 1) + (dz & 1) != 1) {
-                            continue;
-                        }
+            // Use array-based neighbor calculation - faster than HashMap iteration
+            // Cardinal directions: -X, +X, -Y, +Y, -Z, +Z
+            final int[][] neighbors = {
+                {-1, 0, 0}, {1, 0, 0}, {0, -1, 0}, {0, 1, 0}, {0, 0, -1}, {0, 0, 1}
+            };
 
-                        final int neighbourX = sectionX + dx;
-                        final int neighbourY = sectionY + dy;
-                        final int neighbourZ = sectionZ + dz;
+            for (int[] offset : neighbors) {
+                final int neighborX = sectionX + offset[0];
+                final int neighborY = sectionY + offset[1];
+                final int neighborZ = sectionZ + offset[2];
 
-                        final long neighbourKey = CoordinateUtils.getChunkSectionKey(neighbourX, neighbourY, neighbourZ);
-                        if (seen.add(neighbourKey)) {
-                            queue.enqueue(neighbourKey);
-                        }
-                    }
+                final long neighborKey = CoordinateUtils.getChunkSectionKey(neighborX, neighborY, neighborZ);
+                if (seen.add(neighborKey)) {
+                    queue.enqueue(neighborKey);
                 }
             }
 
-            final Optional<PoiSection> poiSectionOptional = load ? poiStorage.getOrLoad(key) : poiStorage.get(key);
-
-            if (poiSectionOptional == null || !poiSectionOptional.isPresent()) {
+            final Optional<PoiSection> poiSectionOpt = load ? poiStorage.getOrLoad(key) : poiStorage.get(key);
+            if (poiSectionOpt == null || !poiSectionOpt.isPresent()) {
                 continue;
             }
 
-            final PoiSection poiSection = poiSectionOptional.get();
-
+            final PoiSection poiSection = poiSectionOpt.get();
             final Map<Holder<PoiType>, Set<PoiRecord>> sectionData = poiSection.getData();
             if (sectionData.isEmpty()) {
                 continue;
             }
 
-            // now we search the section data
-            for (final Map.Entry<Holder<PoiType>, Set<PoiRecord>> entry : sectionData.entrySet()) {
-                if (!villagePlaceType.test(entry.getKey())) {
-                    // filter out by poi type
+            /* Direct array access for type checking
+             This avoids excessive HashMap iteration */
+            for (Map.Entry<Holder<PoiType>, Set<PoiRecord>> entry : sectionData.entrySet()) {
+                final Holder<PoiType> poiType = entry.getKey();
+                if (!villagePlaceType.test(poiType)) {
                     continue;
                 }
 
-                // now we can look at the poi data
-                for (final PoiRecord poiData : entry.getValue()) {
+                // Copy records to an array to avoid iterator overhead
+                final Set<PoiRecord> records = entry.getValue();
+                if (records.isEmpty()) {
+                    continue;
+                }
+
+                // Process each POI record directly
+                for (PoiRecord poiData : records) {
                     if (!occupancyFilter.test(poiData)) {
-                        // filter by occupancy
                         continue;
                     }
 
                     final BlockPos poiPosition = poiData.getPos();
+                    final int poiX = poiPosition.getX();
+                    final int poiZ = poiPosition.getZ();
 
-                    if (Math.abs(poiPosition.getX() - sourcePosition.getX()) > range
-                            || Math.abs(poiPosition.getZ() - sourcePosition.getZ()) > range) {
-                        // out of range for square radius
+                    // Range check
+                    if (poiX < minRangeX || poiX > maxRangeX || poiZ < minRangeZ || poiZ > maxRangeZ) {
                         continue;
                     }
 
-                    // it's important that it's poiPosition.distSqr(source) : the value actually is different IF the values are swapped!
-                    final double dataRange = poiPosition.distSqr(sourcePosition);
+                    // Faster distance calculation
+                    final double dx = poiX - sourceX;
+                    final double dy = poiPosition.getY() - sourceY;
+                    final double dz = poiZ - sourceZ;
+                    final double dataRangeSquared = dx * dx + dy * dy + dz * dz;
 
-                    if (dataRange > maxDistanceSquared) {
-                        // out of range for distance check
+                    if (dataRangeSquared > maxDistanceSquared) {
                         continue;
                     }
 
-                    if (dataRange > furthestDistanceSquared && totalRecords >= max) {
-                        // out of range for distance check
+                    if (dataRangeSquared > furthestDistanceSquared && totalRecords >= max) {
                         continue;
                     }
 
                     if (positionPredicate != null && !positionPredicate.test(poiPosition)) {
-                        // filter by position
                         continue;
                     }
 
-                    if (dataRange > furthestDistanceSquared) {
-                        // we know totalRecords < max, so this entry is now our furthest
-                        furthestDistanceSquared = dataRange;
+                    // Add to candidate buffer
+                    if (candidateCount >= candidateBuffer.length) {
+                        // Expand buffer if needed
+                        PoiRecord[] newBuffer = new PoiRecord[candidateBuffer.length * 2];
+                        System.arraycopy(candidateBuffer, 0, newBuffer, 0, candidateBuffer.length);
+                        candidateBuffer = newBuffer;
                     }
+                    candidateBuffer[candidateCount++] = poiData;
 
-                    closestRecords.computeIfAbsent(dataRange, (final double unused) -> {
-                        return new ArrayList<>();
-                    }).add(poiData);
-
-                    if (++totalRecords >= max) {
-                        if (closestRecords.size() >= 2) {
-                            int entriesInClosest = 0;
-                            final Iterator<Double2ObjectMap.Entry<List<PoiRecord>>> iterator = closestRecords.double2ObjectEntrySet().iterator();
-                            double nextFurthestDistanceSquared = 0.0;
-
-                            for (int i = 0, len = closestRecords.size() - 1; i < len; ++i) {
-                                final Double2ObjectMap.Entry<List<PoiRecord>> recordEntry = iterator.next();
-                                entriesInClosest += recordEntry.getValue().size();
-                                nextFurthestDistanceSquared = recordEntry.getDoubleKey();
-                            }
+                    // Update furthest distance tracking
+                    if (totalRecords < max || dataRangeSquared < furthestDistanceSquared) {
+                        furthestDistanceSquared = Math.max(furthestDistanceSquared, dataRangeSquared);
+                    }
+                }
+            }
 
-                            if (entriesInClosest >= max) {
-                                // the last set of entries at range wont even be considered for sure... nuke em
-                                final Double2ObjectMap.Entry<List<PoiRecord>> recordEntry = iterator.next();
-                                totalRecords -= recordEntry.getValue().size();
-                                iterator.remove();
+            // Process candidates when we have enough or at the end of queue
+            if (candidateCount >= max * 2 || queue.isEmpty()) {
+                if (candidateCount > 0) {
+                    processPoiCandidates(candidateBuffer, candidateCount, sourcePosition, topRecords, max);
 
-                                furthestDistanceSquared = nextFurthestDistanceSquared;
-                            }
-                        }
+                    // Update total records and furthest distance
+                    totalRecords = countNonNullElements(topRecords);
+                    if (totalRecords >= max) {
+                        furthestDistanceSquared = getFurthestDistance(topRecords, sourcePosition);
                     }
+
+                    // Reset candidate buffer
+                    candidateCount = 0;
                 }
             }
         }
 
-        final List<PoiRecord> closestRecordsUnsorted = new ArrayList<>();
+        // Process any remaining candidates
+        if (candidateCount > 0) {
+            processPoiCandidates(candidateBuffer, candidateCount, sourcePosition, topRecords, max);
+        }
 
-        // we're done here, so now just flatten the map and sort it.
+        for (PoiRecord record : topRecords) {
+            if (record != null) {
+                ret.add(record);
+            }
+        }
+    }
 
-        for (final List<PoiRecord> records : closestRecords.values()) {
-            closestRecordsUnsorted.addAll(records);
+    private static void processPoiCandidates(PoiRecord[] candidates, int count, BlockPos sourcePos,
+                                             PoiRecord[] topRecords, int max) {
+        if (count <= 0) return;
+
+        // Cache source coordinates
+        final int sourceX = sourcePos.getX();
+        final int sourceY = sourcePos.getY();
+        final int sourceZ = sourcePos.getZ();
+
+        sortCandidatesBySection(candidates, count);
+
+        // Insert sorted candidates into result array
+        for (int i = 0; i < count; i++) {
+            PoiRecord poiData = candidates[i];
+            if (poiData == null) continue;
+
+            final BlockPos poiPos = poiData.getPos();
+            final double dx = poiPos.getX() - sourceX;
+            final double dy = poiPos.getY() - sourceY;
+            final double dz = poiPos.getZ() - sourceZ;
+            final double distance = dx * dx + dy * dy + dz * dz;
+
+            final int insertPos = findInsertionPoint(topRecords, distance, sourcePos, max);
+
+            if (insertPos < max) {
+                // Shift existing elements to make room
+                if (insertPos < max - 1) {
+                    System.arraycopy(topRecords, insertPos, topRecords, insertPos + 1, max - insertPos - 1);
+                }
+                topRecords[insertPos] = poiData;
+            }
         }
+    }
 
-        // uh oh! we might have multiple records that match the distance sorting!
-        // we need to re-order our results by the way vanilla would have iterated over them.
-        closestRecordsUnsorted.sort((record1, record2) -> {
-            // vanilla iterates the same way we do for data inside sections, so we know the ordering inside a section
-            // is fine and should be preserved (this sort is stable so we're good there)
-            // but they iterate sections by x then by z (like the following)
-            // for (int x = -dx; x <= dx; ++x)
-            //     for (int z = -dz; z <= dz; ++z)
-            //  ....
-            // so we need to reorder such that records with lower chunk z, then lower chunk x come first
-            final BlockPos pos1 = record1.getPos();
-            final BlockPos pos2 = record2.getPos();
+    private static void sortCandidatesBySection(PoiRecord[] candidates, int count) {
+        // Use insertion sort for small arrays - faster than more complex sorts (quicksort etc.)
+        for (int i = 1; i < count; i++) {
+            PoiRecord tmp = candidates[i];
+            if (tmp == null) continue;
+
+            final BlockPos tmpPos = tmp.getPos();
+            final int tmpZ = tmpPos.getZ() >> 4;
+            final int tmpX = tmpPos.getX() >> 4;
+            final int tmpY = tmpPos.getY() >> 4;
+
+            int j = i;
+            while (j > 0) {
+                PoiRecord prev = candidates[j - 1];
+                if (prev == null) {
+                    j--;
+                    continue;
+                }
 
-            final int cx1 = pos1.getX() >> 4;
-            final int cz1 = pos1.getZ() >> 4;
+                final BlockPos prevPos = prev.getPos();
+                final int prevZ = prevPos.getZ() >> 4;
+
+                if (tmpZ < prevZ) {
+                    candidates[j] = prev;
+                    j--;
+                } else if (tmpZ == prevZ) {
+                    final int prevX = prevPos.getX() >> 4;
+                    if (tmpX < prevX) {
+                        candidates[j] = prev;
+                        j--;
+                    } else if (tmpX == prevX) {
+                        final int prevY = prevPos.getY() >> 4;
+                        if (tmpY < prevY) {
+                            candidates[j] = prev;
+                            j--;
+                        } else {
+                            break;
+                        }
+                    } else {
+                        break;
+                    }
+                } else {
+                    break;
+                }
+            }
 
-            final int cx2 = pos2.getX() >> 4;
-            final int cz2 = pos2.getZ() >> 4;
+            candidates[j] = tmp;
+        }
+    }
 
-            if (cz2 != cz1) {
-                // want smaller z
-                return Integer.compare(cz1, cz2);
+    private static int countNonNullElements(Object[] array) {
+        int count = 0;
+        for (Object obj : array) {
+            if (obj != null) count++;
+        }
+        return count;
+    }
+
+    private static double getFurthestDistance(PoiRecord[] records, BlockPos sourcePos) {
+        // Fast path: if the array is full, the last element is the furthest
+        for (int i = records.length - 1; i >= 0; i--) {
+            if (records[i] != null) {
+                final BlockPos pos = records[i].getPos();
+                final int dx = pos.getX() - sourcePos.getX();
+                final int dy = pos.getY() - sourcePos.getY();
+                final int dz = pos.getZ() - sourcePos.getZ();
+                return dx * dx + dy * dy + dz * dz;
             }
+        }
+        return 0.0;
+    }
 
-            if (cx2 != cx1) {
-                // want smaller x
-                return Integer.compare(cx1, cx2);
+
+    private static int findInsertionPoint(PoiRecord[] records, double distance, BlockPos sourcePos, int max) {
+        // Fast path for empty slots at the beginning
+        for (int i = 0; i < max; i++) {
+            if (records[i] == null) {
+                return i;
             }
+        }
 
-            // same chunk
-            // once vanilla has the chunk, it will iterate from all of the chunk sections starting from smaller y
-            // so now we just compare section y, wanting smaller section y
+        // Fast path for the end position
+        if (records[max - 1] != null) {
+            final BlockPos lastPos = records[max - 1].getPos();
+            final int dx = lastPos.getX() - sourcePos.getX();
+            final int dy = lastPos.getY() - sourcePos.getY();
+            final int dz = lastPos.getZ() - sourcePos.getZ();
+            final double lastDist = dx * dx + dy * dy + dz * dz;
 
-            return Integer.compare(pos1.getY() >> 4, pos2.getY() >> 4);
-        });
+            if (distance >= lastDist) {
+                return max; // No insertion needed, it would be beyond the end
+            }
+        }
 
-        // trim out any entries exceeding our maximum
-        for (int i = closestRecordsUnsorted.size() - 1; i >= max; --i) {
-            closestRecordsUnsorted.remove(i);
+        // Binary search to find insertion point
+        int low = 0;
+        int high = max - 1;
+
+        while (low < high) {
+            int mid = (low + high) >>> 1;
+
+            if (records[mid] == null) {
+                // Handle null elements in the array
+                high = mid;
+            } else {
+                final BlockPos midPos = records[mid].getPos();
+                final int dx = midPos.getX() - sourcePos.getX();
+                final int dy = midPos.getY() - sourcePos.getY();
+                final int dz = midPos.getZ() - sourcePos.getZ();
+                double midDist = dx * dx + dy * dy + dz * dz;
+
+                if (midDist > distance) {
+                    high = mid;
+                } else {
+                    low = mid + 1;
+                }
+            }
         }
 
-        // now we match perfectly what vanilla would have outputted, without having to search the whole radius (hopefully).
-        ret.addAll(closestRecordsUnsorted);
+        return low;
     }
 
+    private static final ThreadLocal<Map<PoiRecord, Double>> DISTANCE_CACHE =
+        ThreadLocal.withInitial(() -> new it.unimi.dsi.fastutil.objects.Object2DoubleOpenHashMap<>());
+
+
     public static BlockPos findAnyPoiPosition(final PoiManager poiStorage,
                                               final Predicate<Holder<PoiType>> villagePlaceType,
                                               final Predicate<BlockPos> positionPredicate,
@@ -683,7 +821,7 @@ public final class PoiAccess {
                                            final boolean load,
                                            final int max,
                                            final List<Pair<Holder<PoiType>, BlockPos>> ret) {
-        final Set<BlockPos> positions = new HashSet<>();
+        final ObjectOpenHashSet<BlockPos> positions = new ObjectOpenHashSet<>();
         // pos predicate is last thing that runs before adding to ret.
         final Predicate<BlockPos> newPredicate = (final BlockPos pos) -> {
             if (positionPredicate != null && !positionPredicate.test(pos)) {
