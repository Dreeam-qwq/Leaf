From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Sat, 8 Feb 2025 05:32:30 +0100
Subject: [PATCH] Supporting block cache


diff --git a/net/minecraft/server/level/ChunkMap.java b/net/minecraft/server/level/ChunkMap.java
index 8986c059e7aadb58ae8d9ab7b848de10f9faa6b2..a35f80c6d0c02fd2d70f7c431aa1b621916e01b6 100644
--- a/net/minecraft/server/level/ChunkMap.java
+++ b/net/minecraft/server/level/ChunkMap.java
@@ -719,38 +719,42 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     private boolean anyPlayerCloseEnoughForSpawningInternal(ChunkPos chunkPos, boolean reducedRange) {
-        double blockRange; // Paper - use from event
-        // Spigot end
-        // Paper start - chunk tick iteration optimisation
+        // Precompute chunk center once
+        final double centerX = SectionPos.sectionToBlockCoord(chunkPos.x, 8);
+        final double centerZ = SectionPos.sectionToBlockCoord(chunkPos.z, 8);
         final ca.spottedleaf.moonrise.common.list.ReferenceList<ServerPlayer> players = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getNearbyPlayers().getPlayers(
             chunkPos, ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.SPAWN_RANGE
         );
         if (players == null) {
             return false;
         }
-
-        final ServerPlayer[] raw = players.getRawDataUnchecked();
-        final int len = players.size();
-
-        Objects.checkFromIndexSize(0, len, raw.length);
-        for (int i = 0; i < len; ++i) {
-            final ServerPlayer serverPlayer = raw[i];
-            // Paper start - PlayerNaturallySpawnCreaturesEvent
-            com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent event;
-            blockRange = 16384.0D;
+        final ServerPlayer[] rawPlayers = players.getRawDataUnchecked();
+        final int playerCount = players.size();
+        for (int i = 0; i < playerCount; ++i) {
+            final ServerPlayer player = rawPlayers[i];
+            if (player.isSpectator()) {
+                continue; // Skip spectators early
+            }
+            final double blockRangeSquared;
             if (reducedRange) {
-                event = serverPlayer.playerNaturallySpawnedEvent;
-                if (event == null || event.isCancelled()) continue;
-                blockRange = (double) ((event.getSpawnRadius() << 4) * (event.getSpawnRadius() << 4));
+                // Handle reduced range from PlayerNaturallySpawnCreaturesEvent
+                final com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent event = player.playerNaturallySpawnedEvent;
+                if (event == null || event.isCancelled()) {
+                    continue;
+                }
+                final int spawnRadius = event.getSpawnRadius();
+                blockRangeSquared = (double) (spawnRadius * spawnRadius) * 256.0; // (radius << 4)^2
+            } else {
+                blockRangeSquared = 16384.0D; // Default 128^2
             }
-            // Paper end - PlayerNaturallySpawnCreaturesEvent
-            if (this.playerIsCloseEnoughForSpawning(serverPlayer, chunkPos, blockRange)) {
+            // Calculate squared distance using precomputed center
+            final double dx = player.getX() - centerX;
+            final double dz = player.getZ() - centerZ;
+            if (dx * dx + dz * dz < blockRangeSquared) {
                 return true;
             }
         }
-
         return false;
-        // Paper end - chunk tick iteration optimisation
     }
 
     public List<ServerPlayer> getPlayersCloseForSpawning(ChunkPos chunkPos) {
diff --git a/net/minecraft/world/entity/Entity.java b/net/minecraft/world/entity/Entity.java
index 3beb2b05265cf274f52170018cc22243b06c05e9..d9861d2abc3f37e47b2127eb032a8a83fcaeba3e 100644
--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -1082,19 +1082,38 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         return this.mainSupportingBlockPos.isPresent() && this.mainSupportingBlockPos.get().equals(pos);
     }
 
-    protected void checkSupportingBlock(boolean onGround, @Nullable Vec3 movement) {
+    // Leaf - Cache for supporting block state
+    private boolean canSkipSupportingBlockSearch = false;
+    private BlockState cachedSupportingBlockState = null;
+    protected void checkSupportingBlock(boolean onGround, Vec3 movement) {
+        // Leaf - Skip full check if no movement and cache is valid
+        if (movement == null || (movement.x == 0 && movement.z == 0 && movement.y == 0)) {
+            if (canSkipSupportingBlockSearch) {
+                return;
+            }
+        } else {
+            // Leaf - Invalidate cache on movement
+            canSkipSupportingBlockSearch = false;
+            cachedSupportingBlockState = null;
+        }
+        // Leaf - Original checkSupportingBlock logic
         if (onGround) {
             AABB boundingBox = this.getBoundingBox();
             AABB aabb = new AABB(boundingBox.minX, boundingBox.minY - 1.0E-6, boundingBox.minZ, boundingBox.maxX, boundingBox.minY, boundingBox.maxZ);
-            Optional<BlockPos> optional = this.level.findSupportingBlock(this, aabb);
+            Optional<BlockPos> optional = this.level().findSupportingBlock(this, aabb);
             if (optional.isPresent() || this.onGroundNoBlocks) {
+                // Leaf - Cache the block state if found
+                if (optional.isPresent()) {
+                    BlockPos pos = optional.get();
+                    cachedSupportingBlockState = this.level().getBlockState(pos);
+                    canSkipSupportingBlockSearch = true;
+                }
                 this.mainSupportingBlockPos = optional;
             } else if (movement != null) {
                 AABB aabb1 = aabb.move(-movement.x, 0.0, -movement.z);
-                optional = this.level.findSupportingBlock(this, aabb1);
+                optional = this.level().findSupportingBlock(this, aabb1);
                 this.mainSupportingBlockPos = optional;
             }
-
             this.onGroundNoBlocks = optional.isEmpty();
         } else {
             this.onGroundNoBlocks = false;
@@ -1103,6 +1122,11 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             }
         }
     }
+    // Leaf - Helper method to get cached supporting block state
+    @Nullable
+    public BlockState getCachedSupportingBlock() {
+        return canSkipSupportingBlockSearch ? cachedSupportingBlockState : null;
+    }
 
     public boolean onGround() {
         return this.onGround;
