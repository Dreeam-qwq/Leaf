From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Sun, 16 Feb 2025 01:13:04 +0100
Subject: [PATCH] ensureCapacity with collectTickingChunks


diff --git a/net/minecraft/server/level/ServerChunkCache.java b/net/minecraft/server/level/ServerChunkCache.java
index dd956431bb882daa70267685f2283d0c358336be..7425abf53152b49c554b0057f7c626b8e703f902 100644
--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -573,17 +573,33 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         final ServerChunkCache.ChunkAndHolder[] raw = tickingChunks.getRawDataUnchecked();
         final int size = tickingChunks.size();
 
-        final ChunkMap chunkMap = this.chunkMap;
+        // Precompute chunks near players using a LongSet for O(1) lookups
+        final it.unimi.dsi.fastutil.longs.LongSet nearChunkKeys = new it.unimi.dsi.fastutil.longs.LongOpenHashSet();
+        final int viewDistance = this.chunkMap.serverViewDistance;
+        for (ServerPlayer player : this.level.players()) {
+            ChunkPos playerChunk = player.chunkPosition();
+            // Add all chunks within view distance around the player
+            for (int dx = -viewDistance; dx <= viewDistance; ++dx) {
+                for (int dz = -viewDistance; dz <= viewDistance; ++dz) {
+                    nearChunkKeys.add(ChunkPos.asLong(playerChunk.x + dx, playerChunk.z + dz));
+                }
+            }
+        }
+
+        // Ensure output capacity to avoid resizing
+        if (output instanceof ArrayList<LevelChunk> arrayList) {
+            arrayList.ensureCapacity(size);
+        }
 
         for (int i = 0; i < size; ++i) {
             final ServerChunkCache.ChunkAndHolder chunkAndHolder = raw[i];
             final LevelChunk levelChunk = chunkAndHolder.chunk();
+            final long chunkKey = levelChunk.getPos().toLong();
 
-            if (!this.isChunkNearPlayer(chunkMap, levelChunk.getPos(), levelChunk)) {
-                continue;
+            // Check if the chunk is in the precomputed near chunks
+            if (nearChunkKeys.contains(chunkKey)) {
+                output.add(levelChunk);
             }
-
-            output.add(levelChunk);
         }
         // Paper end - chunk tick iteration optimisation
     }
