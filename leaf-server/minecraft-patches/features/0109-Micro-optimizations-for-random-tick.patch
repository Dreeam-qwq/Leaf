From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Altiami <yoshimo.kristin@gmail.com>
Date: Wed, 5 Feb 2025 12:38:43 -0800
Subject: [PATCH] Micro-optimizations for random tick


diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index b588386ade7a23750dcf5f64b383760404359af2..f08e5279e3b46d717b26b67c1c9050f23f3eaa19 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -901,7 +901,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     // Paper start - optimise random ticking
     private void optimiseRandomTick(final LevelChunk chunk, final int tickSpeed) {
         final LevelChunkSection[] sections = chunk.getSections();
-        final int minSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinSection((ServerLevel)(Object)this);
+        final int minSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinSection(this); // Leaf - no redundant cast
         final net.minecraft.world.level.levelgen.BitRandomSource simpleRandom = this.simpleRandom; // Leaf - Faster random generator - upcasting
         final boolean doubleTickFluids = !ca.spottedleaf.moonrise.common.PlatformHooks.get().configFixMC224294();
 
@@ -910,41 +910,41 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         final int offsetZ = cpos.z << 4;
 
         for (int sectionIndex = 0, sectionsLen = sections.length; sectionIndex < sectionsLen; sectionIndex++) {
-            final int offsetY = (sectionIndex + minSection) << 4;
+            // Leaf start - continue early
             final LevelChunkSection section = sections[sectionIndex];
-            final net.minecraft.world.level.chunk.PalettedContainer<net.minecraft.world.level.block.state.BlockState> states = section.states;
             if (!section.isRandomlyTickingBlocks()) {
                 continue;
             }
+            final int offsetY = (sectionIndex + minSection) << 4;
+            final net.minecraft.world.level.chunk.PalettedContainer<net.minecraft.world.level.block.state.BlockState> states = section.states;
+            // Leaf end
 
-            final ca.spottedleaf.moonrise.common.list.ShortList tickList = ((ca.spottedleaf.moonrise.patches.block_counting.BlockCountingChunkSection)section).moonrise$getTickingBlockList();
+            final ca.spottedleaf.moonrise.common.list.ShortList tickList = section.moonrise$getTickingBlockList(); // Leaf - no redundant cast
 
             for (int i = 0; i < tickSpeed; ++i) {
-                final int tickingBlocks = tickList.size();
                 final int index = simpleRandom.nextInt() & ((16 * 16 * 16) - 1);
 
-                if (index >= tickingBlocks) {
+                if (index >= tickList.size()) { // Leaf - inline one-time value
                     // most of the time we fall here
                     continue;
                 }
 
-                final int location = (int)tickList.getRaw(index) & 0xFFFF;
+                final int location = tickList.getRaw(index); // Leaf - no unnecessary operations
                 final BlockState state = states.get(location);
 
                 // do not use a mutable pos, as some random tick implementations store the input without calling immutable()!
-                final BlockPos pos = new BlockPos((location & 15) | offsetX, ((location >>> (4 + 4)) & 15) | offsetY, ((location >>> 4) & 15) | offsetZ);
+                final BlockPos pos = new BlockPos((location & 15) | offsetX, (location >>> (4 + 4)) | offsetY, ((location >>> 4) & 15) | offsetZ); // Leaf - no redundant mask
 
-                state.randomTick((ServerLevel)(Object)this, pos, simpleRandom);
+                state.randomTick(this, pos, simpleRandom); // Leaf - no redundant cast
                 if (doubleTickFluids) {
                     final FluidState fluidState = state.getFluidState();
                     if (fluidState.isRandomlyTicking()) {
-                        fluidState.randomTick((ServerLevel)(Object)this, pos, simpleRandom);
+                        fluidState.randomTick(this, pos, simpleRandom); // Leaf - no redundant cast
                     }
                 }
             }
         }
-
-        return;
+        // Leaf - no redundant return
     }
     // Paper end - optimise random ticking
 
