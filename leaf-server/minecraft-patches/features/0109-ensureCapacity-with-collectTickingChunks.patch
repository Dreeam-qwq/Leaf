From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Sun, 16 Feb 2025 01:13:04 +0100
Subject: [PATCH] ensureCapacity with collectTickingChunks


diff --git a/net/minecraft/server/level/ServerChunkCache.java b/net/minecraft/server/level/ServerChunkCache.java
index dd956431bb882daa70267685f2283d0c358336be..0155810aa0c6335abe30a87c8a8ea57591b8e5e3 100644
--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -573,17 +573,40 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         final ServerChunkCache.ChunkAndHolder[] raw = tickingChunks.getRawDataUnchecked();
         final int size = tickingChunks.size();
 
-        final ChunkMap chunkMap = this.chunkMap;
+        // Ensure output capacity to avoid resizing
+        if (output instanceof ArrayList<LevelChunk> arrayList) {
+            arrayList.ensureCapacity(size);
+        }
+
+        // Pre-calculate player view rectangles instead of using a LongOpenHashSet
+        List<ServerPlayer> players = this.level.players();
+        int playerCount = players.size();
+        int viewDistance = this.chunkMap.serverViewDistance;
+
+        // Store player view boundaries for efficient checking
+        int[][] playerViewBounds = new int[playerCount][4]; // [minX, maxX, minZ, maxZ]
+        for (int i = 0; i < playerCount; i++) {
+            ChunkPos playerChunk = players.get(i).chunkPosition();
+            playerViewBounds[i][0] = playerChunk.x - viewDistance;
+            playerViewBounds[i][1] = playerChunk.x + viewDistance;
+            playerViewBounds[i][2] = playerChunk.z - viewDistance;
+            playerViewBounds[i][3] = playerChunk.z + viewDistance;
+        }
 
+        // Check each chunk against player view boundaries
         for (int i = 0; i < size; ++i) {
             final ServerChunkCache.ChunkAndHolder chunkAndHolder = raw[i];
             final LevelChunk levelChunk = chunkAndHolder.chunk();
-
-            if (!this.isChunkNearPlayer(chunkMap, levelChunk.getPos(), levelChunk)) {
-                continue;
+            final ChunkPos pos = levelChunk.getPos();
+
+            // Check if chunk is in any player's view distance
+            for (int j = 0; j < playerCount; j++) {
+                if (pos.x >= playerViewBounds[j][0] && pos.x <= playerViewBounds[j][1] &&
+                    pos.z >= playerViewBounds[j][2] && pos.z <= playerViewBounds[j][3]) {
+                    output.add(levelChunk);
+                    break;
+                }
             }
-
-            output.add(levelChunk);
         }
         // Paper end - chunk tick iteration optimisation
     }
