From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Sat, 22 Feb 2025 12:10:24 +0100
Subject: [PATCH] Rewrite findNearestPoiRecords


diff --git a/io/papermc/paper/util/PoiAccess.java b/io/papermc/paper/util/PoiAccess.java
index f39294b1f83c4022be5ced4da781103a1eee2daf..f2cfa6725a15189887d61d32c174254dfebc1b74 100644
--- a/io/papermc/paper/util/PoiAccess.java
+++ b/io/papermc/paper/util/PoiAccess.java
@@ -8,6 +8,8 @@ import it.unimi.dsi.fastutil.doubles.Double2ObjectRBTreeMap;
 import it.unimi.dsi.fastutil.longs.LongArrayFIFOQueue;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import java.util.function.BiPredicate;
+
+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.util.Mth;
@@ -126,7 +128,7 @@ public final class PoiAccess {
                                                    final PoiManager.Occupancy occupancy,
                                                    final boolean load,
                                                    final Set<BlockPos> ret) {
-        final Set<BlockPos> positions = new HashSet<>();
+        final ObjectOpenHashSet<BlockPos> positions = new ObjectOpenHashSet<>();
         // pos predicate is last thing that runs before adding to ret.
         final Predicate<BlockPos> newPredicate = (final BlockPos pos) -> {
             if (positionPredicate != null && !positionPredicate.test(pos)) {
@@ -400,7 +402,7 @@ public final class PoiAccess {
                                                final boolean load,
                                                final int max,
                                                final List<Pair<Holder<PoiType>, BlockPos>> ret) {
-        final Set<BlockPos> positions = new HashSet<>();
+        final ObjectOpenHashSet<BlockPos> positions = new ObjectOpenHashSet<>();
         // pos predicate is last thing that runs before adding to ret.
         final Predicate<BlockPos> newPredicate = (final BlockPos pos) -> {
             if (positionPredicate != null && !positionPredicate.test(pos)) {
@@ -451,27 +453,44 @@ public final class PoiAccess {
                                              final List<PoiRecord> ret) {
         final Predicate<? super PoiRecord> occupancyFilter = occupancy.getTest();
 
-        final Double2ObjectRBTreeMap<List<PoiRecord>> closestRecords = new Double2ObjectRBTreeMap<>();
+        // Use a primitive-optimized map instead of Double2ObjectRBTreeMap with ArrayList
+        // Maintain a simple array of records with max size and current max distance
+        final PoiRecord[] topRecords = new PoiRecord[max];
         int totalRecords = 0;
         double furthestDistanceSquared = maxDistanceSquared;
 
-        final int lowerX = Mth.floor(sourcePosition.getX() - range) >> 4;
+        // Cache position coordinates to avoid repeated method calls
+        final int sourceX = sourcePosition.getX();
+        final int sourceY = sourcePosition.getY();
+        final int sourceZ = sourcePosition.getZ();
+
+        final int lowerX = Mth.floor(sourceX - range) >> 4;
         final int lowerY = WorldUtil.getMinSection(poiStorage.moonrise$getWorld());
-        final int lowerZ = Mth.floor(sourcePosition.getZ() - range) >> 4;
-        final int upperX = Mth.floor(sourcePosition.getX() + range) >> 4;
+        final int lowerZ = Mth.floor(sourceZ - range) >> 4;
+        final int upperX = Mth.floor(sourceX + range) >> 4;
         final int upperY = WorldUtil.getMaxSection(poiStorage.moonrise$getWorld());
-        final int upperZ = Mth.floor(sourcePosition.getZ() + range) >> 4;
+        final int upperZ = Mth.floor(sourceZ + range) >> 4;
 
-        final int centerX = sourcePosition.getX() >> 4;
-        final int centerY = Mth.clamp(sourcePosition.getY() >> 4, lowerY, upperY);
-        final int centerZ = sourcePosition.getZ() >> 4;
+        final int centerX = sourceX >> 4;
+        final int centerY = Mth.clamp(sourceY >> 4, lowerY, upperY);
+        final int centerZ = sourceZ >> 4;
         final long centerKey = CoordinateUtils.getChunkSectionKey(centerX, centerY, centerZ);
 
-        final LongArrayFIFOQueue queue = new LongArrayFIFOQueue();
-        final LongOpenHashSet seen = new LongOpenHashSet();
+        // Pre-calculate range bounds for faster filtering
+        final int minRangeX = sourceX - range;
+        final int maxRangeX = sourceX + range;
+        final int minRangeZ = sourceZ - range;
+        final int maxRangeZ = sourceZ + range;
+
+        // Use primitive queue for better performance
+        final LongArrayFIFOQueue queue = new LongArrayFIFOQueue(128); // Pre-allocate reasonable size
+        final LongOpenHashSet seen = new LongOpenHashSet(128);
         seen.add(centerKey);
         queue.enqueue(centerKey);
 
+        // Temporary list to avoid sorting at every iteration
+        final List<PoiRecord> candidateRecords = new ArrayList<>(max * 2);
+
         while (!queue.isEmpty()) {
             final long key = queue.dequeueLong();
             final int sectionX = CoordinateUtils.getChunkSectionX(key);
@@ -484,38 +503,33 @@ public final class PoiAccess {
             }
 
             final double sectionDistanceSquared = getSmallestDistanceSquared(
-                    (sectionX << 4) + 0.5,
-                    (sectionY << 4) + 0.5,
-                    (sectionZ << 4) + 0.5,
-                    (sectionX << 4) + 15.5,
-                    (sectionY << 4) + 15.5,
-                    (sectionZ << 4) + 15.5,
-                    (double) sourcePosition.getX(), (double) sourcePosition.getY(), (double) sourcePosition.getZ()
+                (sectionX << 4) + 0.5,
+                (sectionY << 4) + 0.5,
+                (sectionZ << 4) + 0.5,
+                (sectionX << 4) + 15.5,
+                (sectionY << 4) + 15.5,
+                (sectionZ << 4) + 15.5,
+                sourceX, sourceY, sourceZ
             );
 
             if (sectionDistanceSquared > (totalRecords >= max ? furthestDistanceSquared : maxDistanceSquared)) {
                 continue;
             }
 
-            // queue all neighbours
-            for (int dz = -1; dz <= 1; ++dz) {
-                for (int dx = -1; dx <= 1; ++dx) {
-                    for (int dy = -1; dy <= 1; ++dy) {
-                        // -1 and 1 have the 1st bit set. so just add up the first bits, and it will tell us how many
-                        // values are set. we only care about cardinal neighbours, so, we only care if one value is set
-                        if ((dx & 1) + (dy & 1) + (dz & 1) != 1) {
-                            continue;
-                        }
+            // Queue neighbors - use a more efficient approach
+            for (int i = 0; i < 6; i++) {
+                // Get neighbor coordinates using a lookup approach instead of nested loops
+                final int dx = i == 0 ? -1 : (i == 1 ? 1 : 0);
+                final int dy = i == 2 ? -1 : (i == 3 ? 1 : 0);
+                final int dz = i == 4 ? -1 : (i == 5 ? 1 : 0);
 
-                        final int neighbourX = sectionX + dx;
-                        final int neighbourY = sectionY + dy;
-                        final int neighbourZ = sectionZ + dz;
+                final int neighbourX = sectionX + dx;
+                final int neighbourY = sectionY + dy;
+                final int neighbourZ = sectionZ + dz;
 
-                        final long neighbourKey = CoordinateUtils.getChunkSectionKey(neighbourX, neighbourY, neighbourZ);
-                        if (seen.add(neighbourKey)) {
-                            queue.enqueue(neighbourKey);
-                        }
-                    }
+                final long neighbourKey = CoordinateUtils.getChunkSectionKey(neighbourX, neighbourY, neighbourZ);
+                if (seen.add(neighbourKey)) {
+                    queue.enqueue(neighbourKey);
                 }
             }
 
@@ -532,132 +546,186 @@ public final class PoiAccess {
                 continue;
             }
 
-            // now we search the section data
+            // Process POI data in this section
             for (final Map.Entry<Holder<PoiType>, Set<PoiRecord>> entry : sectionData.entrySet()) {
                 if (!villagePlaceType.test(entry.getKey())) {
-                    // filter out by poi type
                     continue;
                 }
 
-                // now we can look at the poi data
                 for (final PoiRecord poiData : entry.getValue()) {
                     if (!occupancyFilter.test(poiData)) {
-                        // filter by occupancy
                         continue;
                     }
 
                     final BlockPos poiPosition = poiData.getPos();
+                    final int poiX = poiPosition.getX();
+                    final int poiZ = poiPosition.getZ();
 
-                    if (Math.abs(poiPosition.getX() - sourcePosition.getX()) > range
-                            || Math.abs(poiPosition.getZ() - sourcePosition.getZ()) > range) {
-                        // out of range for square radius
+                    // Fast range check using pre-calculated bounds
+                    if (poiX < minRangeX || poiX > maxRangeX || poiZ < minRangeZ || poiZ > maxRangeZ) {
                         continue;
                     }
 
-                    // it's important that it's poiPosition.distSqr(source) : the value actually is different IF the values are swapped!
-                    final double dataRange = poiPosition.distSqr(sourcePosition);
+                    // Faster distance calculation
+                    final double dx = poiX - sourceX;
+                    final double dy = poiPosition.getY() - sourceY;
+                    final double dz = poiZ - sourceZ;
+                    final double dataRangeSquared = dx * dx + dy * dy + dz * dz;
 
-                    if (dataRange > maxDistanceSquared) {
-                        // out of range for distance check
+                    if (dataRangeSquared > maxDistanceSquared) {
                         continue;
                     }
 
-                    if (dataRange > furthestDistanceSquared && totalRecords >= max) {
-                        // out of range for distance check
+                    if (dataRangeSquared > furthestDistanceSquared && totalRecords >= max) {
                         continue;
                     }
 
                     if (positionPredicate != null && !positionPredicate.test(poiPosition)) {
-                        // filter by position
                         continue;
                     }
 
-                    if (dataRange > furthestDistanceSquared) {
-                        // we know totalRecords < max, so this entry is now our furthest
-                        furthestDistanceSquared = dataRange;
+                    // Add to candidates list
+                    candidateRecords.add(poiData);
+
+                    // Track the current max distance
+                    if (totalRecords < max || dataRangeSquared < furthestDistanceSquared) {
+                        furthestDistanceSquared = Math.max(furthestDistanceSquared, dataRangeSquared);
                     }
+                }
+            }
 
-                    closestRecords.computeIfAbsent(dataRange, (final double unused) -> {
-                        return new ArrayList<>();
-                    }).add(poiData);
+            // Process candidate records if we've accumulated enough or reached the end
+            if (candidateRecords.size() >= max * 2 || queue.isEmpty()) {
+                processCandidates(candidateRecords, sourcePosition, topRecords, max);
 
-                    if (++totalRecords >= max) {
-                        if (closestRecords.size() >= 2) {
-                            int entriesInClosest = 0;
-                            final Iterator<Double2ObjectMap.Entry<List<PoiRecord>>> iterator = closestRecords.double2ObjectEntrySet().iterator();
-                            double nextFurthestDistanceSquared = 0.0;
+                // Update furthest distance from our topRecords array
+                if (totalRecords >= max) {
+                    furthestDistanceSquared = getMaxDistanceInTopRecords(topRecords, sourcePosition);
+                }
 
-                            for (int i = 0, len = closestRecords.size() - 1; i < len; ++i) {
-                                final Double2ObjectMap.Entry<List<PoiRecord>> recordEntry = iterator.next();
-                                entriesInClosest += recordEntry.getValue().size();
-                                nextFurthestDistanceSquared = recordEntry.getDoubleKey();
-                            }
+                totalRecords = countNonNullRecords(topRecords);
+                candidateRecords.clear();
+            }
+        }
 
-                            if (entriesInClosest >= max) {
-                                // the last set of entries at range wont even be considered for sure... nuke em
-                                final Double2ObjectMap.Entry<List<PoiRecord>> recordEntry = iterator.next();
-                                totalRecords -= recordEntry.getValue().size();
-                                iterator.remove();
+        // Process any remaining candidates
+        if (!candidateRecords.isEmpty()) {
+            processCandidates(candidateRecords, sourcePosition, topRecords, max);
+        }
 
-                                furthestDistanceSquared = nextFurthestDistanceSquared;
-                            }
-                        }
-                    }
-                }
+        // Add final results to return list
+        for (PoiRecord record : topRecords) {
+            if (record != null) {
+                ret.add(record);
             }
         }
+    }
 
-        final List<PoiRecord> closestRecordsUnsorted = new ArrayList<>();
+    private static int countNonNullRecords(PoiRecord[] records) {
+        int count = 0;
+        for (PoiRecord record : records) {
+            if (record != null) count++;
+        }
+        return count;
+    }
 
-        // we're done here, so now just flatten the map and sort it.
+    private static void processCandidates(List<PoiRecord> candidates, BlockPos sourcePosition,
+                                          PoiRecord[] topRecords, int max) {
+        if (candidates.isEmpty()) return;
 
-        for (final List<PoiRecord> records : closestRecords.values()) {
-            closestRecordsUnsorted.addAll(records);
-        }
+        // Cache source position coordinates
+        final int sourceX = sourcePosition.getX();
+        final int sourceY = sourcePosition.getY();
+        final int sourceZ = sourcePosition.getZ();
 
-        // uh oh! we might have multiple records that match the distance sorting!
-        // we need to re-order our results by the way vanilla would have iterated over them.
-        closestRecordsUnsorted.sort((record1, record2) -> {
-            // vanilla iterates the same way we do for data inside sections, so we know the ordering inside a section
-            // is fine and should be preserved (this sort is stable so we're good there)
-            // but they iterate sections by x then by z (like the following)
-            // for (int x = -dx; x <= dx; ++x)
-            //     for (int z = -dz; z <= dz; ++z)
-            //  ....
-            // so we need to reorder such that records with lower chunk z, then lower chunk x come first
+        // Simple stable sort based on chunk position
+        candidates.sort((record1, record2) -> {
             final BlockPos pos1 = record1.getPos();
             final BlockPos pos2 = record2.getPos();
 
-            final int cx1 = pos1.getX() >> 4;
             final int cz1 = pos1.getZ() >> 4;
+            final int cz2 = pos2.getZ() >> 4;
+            if (cz1 != cz2) return Integer.compare(cz1, cz2);
 
+            final int cx1 = pos1.getX() >> 4;
             final int cx2 = pos2.getX() >> 4;
-            final int cz2 = pos2.getZ() >> 4;
+            if (cx1 != cx2) return Integer.compare(cx1, cx2);
 
-            if (cz2 != cz1) {
-                // want smaller z
-                return Integer.compare(cz1, cz2);
+            return Integer.compare(pos1.getY() >> 4, pos2.getY() >> 4);
+        });
+
+        // Process in order
+        for (PoiRecord poiData : candidates) {
+            final BlockPos poiPosition = poiData.getPos();
+
+            // Direct distance calculation is faster than caching for most cases
+            final double dx = poiPosition.getX() - sourceX;
+            final double dy = poiPosition.getY() - sourceY;
+            final double dz = poiPosition.getZ() - sourceZ;
+            final double distance = dx * dx + dy * dy + dz * dz;
+
+            // Find insertion point using binary search - much faster for large arrays
+            int insertPos = findInsertionPoint(topRecords, distance, sourcePosition, max);
+
+            // Only proceed if we have a valid insertion point
+            if (insertPos < max) {
+                // Shift elements to make space - start from the end
+                for (int i = max - 1; i > insertPos; i--) {
+                    topRecords[i] = topRecords[i - 1];
+                }
+                topRecords[insertPos] = poiData;
             }
+        }
+    }
 
-            if (cx2 != cx1) {
-                // want smaller x
-                return Integer.compare(cx1, cx2);
+    private static int findInsertionPoint(PoiRecord[] records, double distance, BlockPos sourcePos, int max) {
+        // Fast path for empty slots
+        for (int i = 0; i < max; i++) {
+            if (records[i] == null) {
+                return i;
             }
+        }
 
-            // same chunk
-            // once vanilla has the chunk, it will iterate from all of the chunk sections starting from smaller y
-            // so now we just compare section y, wanting smaller section y
+        // If array is full, check if this record is closer than the furthest one
+        double lastDistance = records[max-1].getPos().distSqr(sourcePos);
+        if (distance >= lastDistance) {
+            return max; // No insertion needed
+        }
 
-            return Integer.compare(pos1.getY() >> 4, pos2.getY() >> 4);
-        });
+        // Binary search to find insertion point
+        int low = 0;
+        int high = max - 1;
 
-        // trim out any entries exceeding our maximum
-        for (int i = closestRecordsUnsorted.size() - 1; i >= max; --i) {
-            closestRecordsUnsorted.remove(i);
+        while (low < high) {
+            int mid = (low + high) >>> 1;
+            double midDist = records[mid].getPos().distSqr(sourcePos);
+
+            if (midDist > distance) {
+                high = mid;
+            } else {
+                low = mid + 1;
+            }
         }
 
-        // now we match perfectly what vanilla would have outputted, without having to search the whole radius (hopefully).
-        ret.addAll(closestRecordsUnsorted);
+        return low;
+    }
+
+    private static final ThreadLocal<Map<PoiRecord, Double>> DISTANCE_CACHE =
+        ThreadLocal.withInitial(() -> new it.unimi.dsi.fastutil.objects.Object2DoubleOpenHashMap<>());
+
+    private static double getMaxDistanceInTopRecords(PoiRecord[] records, BlockPos sourcePos) {
+        if (records[0] == null) {
+            return 0.0; // No records yet
+        }
+
+        // When array is full, the last record is always the furthest
+        for (int i = records.length - 1; i >= 0; i--) {
+            if (records[i] != null) {
+                return records[i].getPos().distSqr(sourcePos);
+            }
+        }
+
+        return 0.0;
     }
 
     public static BlockPos findAnyPoiPosition(final PoiManager poiStorage,
@@ -683,7 +751,7 @@ public final class PoiAccess {
                                            final boolean load,
                                            final int max,
                                            final List<Pair<Holder<PoiType>, BlockPos>> ret) {
-        final Set<BlockPos> positions = new HashSet<>();
+        final ObjectOpenHashSet<BlockPos> positions = new ObjectOpenHashSet<>();
         // pos predicate is last thing that runs before adding to ret.
         final Predicate<BlockPos> newPredicate = (final BlockPos pos) -> {
             if (positionPredicate != null && !positionPredicate.test(pos)) {
