From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Thu, 13 Feb 2025 17:19:14 +0100
Subject: [PATCH] Use Grid based Spatial Partitioning on isChunkNearPlayer


diff --git a/net/minecraft/server/level/ServerChunkCache.java b/net/minecraft/server/level/ServerChunkCache.java
index b046103ea0634ecaf2facf20f447a5db0fa0115e..c736620414353388d122650af2ffec033141c6fa 100644
--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -3,16 +3,14 @@ package net.minecraft.server.level;
 import com.google.common.annotations.VisibleForTesting;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
+import it.unimi.dsi.fastutil.objects.Object2LongMap;
+import it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ReferenceArrayList;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
 import java.io.IOException;
 import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CompletionStage;
-import java.util.concurrent.Executor;
+import java.util.*;
+import java.util.concurrent.*;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
@@ -68,6 +66,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     private final ChunkAccess[] lastChunk = new ChunkAccess[4];
     private final List<LevelChunk> tickingChunks = new ArrayList<>();
     private final Set<ChunkHolder> chunkHoldersToBroadcast = new ReferenceOpenHashSet<>();
+
     @Nullable
     @VisibleForDebug
     private NaturalSpawner.SpawnState lastSpawnState;
@@ -149,48 +148,129 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         return load ? this.syncLoad(chunkX, chunkZ, toStatus) : null;
     }
     // Paper end - rewrite chunk system
-    // Paper start - chunk tick iteration optimisations
-    private final net.minecraft.world.level.levelgen.BitRandomSource shuffleRandom = org.dreeam.leaf.config.modules.opt.FastRNG.enabled ? new org.dreeam.leaf.util.math.random.FasterRandomSource(0L) : new ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom(0L); // Leaf - Faster random generator
-    private boolean isChunkNearPlayer(final ChunkMap chunkMap, final ChunkPos chunkPos, final LevelChunk levelChunk) {
-        // Early exit if there's no nearby players data
-        final ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkData chunkData = ((ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkSystemChunkHolder)((ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkSystemLevelChunk)levelChunk).moonrise$getChunkAndHolder().holder())
-            .moonrise$getRealChunkHolder().holderData;
-        final ca.spottedleaf.moonrise.common.misc.NearbyPlayers.TrackedChunk nearbyPlayers = chunkData.nearbyPlayers;
-        if (nearbyPlayers == null) {
-            return false;
-        }
 
-        // Get players in spawn range efficiently
-        final ca.spottedleaf.moonrise.common.list.ReferenceList<ServerPlayer> players = nearbyPlayers.getPlayers(ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.SPAWN_RANGE);
+    private static final int GRID_SIZE = 8; // 128 block grid cells
+    private static final int GRID_CACHE_SIZE = 1024; // Power of 2 for fast modulo
+    private final ReferenceArrayList<ServerPlayer>[][] playerGridCache = new ReferenceArrayList[GRID_CACHE_SIZE][GRID_CACHE_SIZE];
+    private final Object2LongMap<ServerPlayer> playerGridPositions = new Object2LongOpenHashMap<>();
+
+    private final Object gridLock = new Object();
+
+    private void updatePlayerGridPosition(ServerPlayer player) {
+        final ChunkPos chunkPos = player.chunkPosition();
+        final int gridX = chunkPos.x / GRID_SIZE;
+        final int gridZ = chunkPos.z / GRID_SIZE;
+
+        // Calculate cache indices using bitmask (fast modulo)
+        final int cacheX = gridX & (GRID_CACHE_SIZE - 1);
+        final int cacheZ = gridZ & (GRID_CACHE_SIZE - 1);
+
+        synchronized(gridLock) {
+            // Remove from old position
+            final long oldKey = playerGridPositions.getOrDefault(player, -1);
+            if(oldKey != -1) {
+                final int oldCacheX = (int) (oldKey >> 32) & (GRID_CACHE_SIZE - 1);
+                final int oldCacheZ = (int) oldKey & (GRID_CACHE_SIZE - 1);
+                removeFromCache(oldCacheX, oldCacheZ, player);
+            }
 
-        // Early exit if no players
-        if (players == null) {
-            return false;
+            // Add to new position
+            addToCache(cacheX, cacheZ, player);
+            playerGridPositions.put(player, ((long) gridX << 32) | gridZ);
         }
+    }
 
-        // Use raw array for fastest iteration
-        final ServerPlayer[] raw = players.getRawDataUnchecked();
-        final int len = players.size();
-        // Precompute chunk center coordinates to avoid repeated calculations
-        final double chunkCenterX = (chunkPos.x << 4) + 8.0;
-        final double chunkCenterZ = (chunkPos.z << 4) + 8.0;
+    private void addToCache(int x, int z, ServerPlayer player) {
+        ReferenceArrayList<ServerPlayer> list = playerGridCache[x][z];
+        if(list == null) {
+            list = new ReferenceArrayList<>(2); // Initial small capacity
+            playerGridCache[x][z] = list;
+        }
+        // Check using reference equality
+        for(int i = 0; i < list.size(); i++) {
+            if(list.get(i) == player) return;
+        }
+        list.add(player);
+    }
 
-        // Inline distance check to avoid method call overhead
-        for (int i = 0; i < len; ++i) {
-            final ServerPlayer player = raw[i];
+    private void removeFromCache(int x, int z, ServerPlayer player) {
+        ReferenceArrayList<ServerPlayer> list = playerGridCache[x][z];
+        if(list != null) {
+            for(int i = 0; i < list.size(); i++) {
+                if(list.get(i) == player) {
+                    list.remove(i);
+                    break;
+                }
+            }
+        }
+    }
 
-            // Quick null and spectator check
-            if (player == null || player.isSpectator()) {
-                continue;
+    public void removeFromGrid(ServerPlayer player) {
+        synchronized(gridLock) {
+            final long oldKey = playerGridPositions.removeLong(player);
+            if(oldKey != -1) {
+                final int oldCacheX = (int) (oldKey >> 32) & (GRID_CACHE_SIZE - 1);
+                final int oldCacheZ = (int) oldKey & (GRID_CACHE_SIZE - 1);
+                removeFromCache(oldCacheX, oldCacheZ, player);
             }
+        }
+    }
 
-            // Squared distance check is faster than sqrt
-            final double dx = player.getX() - chunkCenterX;
-            final double dz = player.getZ() - chunkCenterZ;
+    // Paper start - chunk tick iteration optimisations
+    private final net.minecraft.world.level.levelgen.BitRandomSource shuffleRandom = org.dreeam.leaf.config.modules.opt.FastRNG.enabled ? new org.dreeam.leaf.util.math.random.FasterRandomSource(0L) : new ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom(0L); // Leaf - Faster random generator
+    private boolean isChunkNearPlayer(ChunkMap chunkMap, ChunkPos chunkPos, LevelChunk levelChunk) {
+        final double centerX = (double)(chunkPos.x << 4) + 8.0D;
+        final double centerZ = (double)(chunkPos.z << 4) + 8.0D;
+
+        final int gridX = chunkPos.x >> 3;
+        final int gridZ = chunkPos.z >> 3;
+
+        // Cache array accesses
+        final ReferenceArrayList[][] gridCache = this.playerGridCache;
+        final int gridMask = GRID_CACHE_SIZE - 1;
+
+        // Directly use & for fast modulo since GRID_CACHE_SIZE is power of 2
+        final int baseX = gridX & gridMask;
+        final int baseZ = gridZ & gridMask;
+
+        // Unroll the loop for the most common case (center cell)
+        ReferenceArrayList<ServerPlayer> players = gridCache[baseX][baseZ];
+        if (players != null) {
+            // Use raw array access for better performance
+            ServerPlayer[] playerArray = players.toArray(new ServerPlayer[0]);
+            for (ServerPlayer player : playerArray) {
+                if (!player.isSpectator()) {
+                    double dx = player.getX() - centerX;
+                    double dz = player.getZ() - centerZ;
+                    if (dx * dx + dz * dz < 16384.0D) { // 128 * 128
+                        return true;
+                    }
+                }
+            }
+        }
 
-            // Use 16384.0 (128^2) as the spawn range squared
-            if (dx * dx + dz * dz < 16384.0) {
-                return true;
+        // Check adjacent cells if needed
+        for (int dx = -1; dx <= 1; dx++) {
+            final int cx = (baseX + dx) & gridMask;
+            for (int dz = -1; dz <= 1; dz++) {
+                // Skip center cell as it was already checked
+                if (dx == 0 && dz == 0) continue;
+
+                final int cz = (baseZ + dz) & gridMask;
+                players = gridCache[cx][cz];
+
+                if (players != null) {
+                    ServerPlayer[] playerArray = players.toArray(new ServerPlayer[0]);
+                    for (ServerPlayer player : playerArray) {
+                        if (!player.isSpectator()) {
+                            double diffX = player.getX() - centerX;
+                            double diffZ = player.getZ() - centerZ;
+                            if (diffX * diffX + diffZ * diffZ < 16384.0D) { // 128 * 128
+                                return true;
+                            }
+                        }
+                    }
+                }
             }
         }
 
@@ -509,6 +589,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
         this.chunkMap.tick(hasTimeLeft);
         this.clearCache();
+        this.level.addPlayerCleanupListener(this::removeFromGrid);
     }
 
     private void tickChunks() {
@@ -780,15 +861,24 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     public void move(ServerPlayer player) {
         if (!player.isRemoved()) {
             this.chunkMap.move(player);
+            this.updatePlayerGridPosition(player); // Update grid position
         }
     }
 
     public void removeEntity(Entity entity) {
         this.chunkMap.removeEntity(entity);
+        // Add grid cleanup for players
+        if (entity instanceof ServerPlayer player) {
+            this.removeFromGrid(player);
+        }
     }
 
     public void addEntity(Entity entity) {
         this.chunkMap.addEntity(entity);
+        // Add player to grid when first added
+        if (entity instanceof ServerPlayer player) {
+            this.updatePlayerGridPosition(player);
+        }
     }
 
     public void broadcastAndSend(Entity entity, Packet<?> packet) {
diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index dd1827931e7a2f771444867ad556444de5001060..a7113c957af6c87b14466dd1ce1f0b2673529ddf 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -29,6 +29,7 @@ import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
+import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
@@ -217,6 +218,11 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private final alternate.current.wire.WireHandler wireHandler = new alternate.current.wire.WireHandler(this); // Paper - optimize redstone (Alternate Current)
     public boolean hasRidableMoveEvent = false; // Purpur - Ridables
     final List<ServerPlayer> realPlayers; // Leaves - skip
+    private final List<Consumer<ServerPlayer>> playerCleanupListeners = new ArrayList<>();
+
+    public void addPlayerCleanupListener(Consumer<ServerPlayer> listener) {
+        this.playerCleanupListeners.add(listener);
+    }
 
     public LevelChunk getChunkIfLoaded(int x, int z) {
         return this.chunkSource.getChunkAtIfLoadedImmediately(x, z); // Paper - Use getChunkIfLoadedImmediately
@@ -1614,6 +1620,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     public void removePlayerImmediately(ServerPlayer player, Entity.RemovalReason reason) {
         player.remove(reason, null); // CraftBukkit - add Bukkit remove cause
+        List<Consumer<ServerPlayer>> listeners = this.playerCleanupListeners;
+        for (int i = 0, len = listeners.size(); i < len; ++i) {listeners.get(i).accept(player);}
     }
 
     // CraftBukkit start
