From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Sun, 9 Feb 2025 18:09:27 +0100
Subject: [PATCH] Use QuadTree on isChunkNearPlayers


diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/queue/ChunkUnloadQueue.java b/ca/spottedleaf/moonrise/patches/chunk_system/queue/ChunkUnloadQueue.java
index 7eafc5b7cba23d8dec92ecc1050afe3fd8c9e309..4429eb0ce65da7211d7136e3b9569fa09a924d79 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/queue/ChunkUnloadQueue.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/queue/ChunkUnloadQueue.java
@@ -141,4 +141,4 @@ public final class ChunkUnloadQueue {
             this.order = order;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/net/minecraft/server/level/ServerChunkCache.java b/net/minecraft/server/level/ServerChunkCache.java
index dd956431bb882daa70267685f2283d0c358336be..9c8c38ab69c2fc21d5e0fa75e262af29db7314a8 100644
--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -68,6 +68,12 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     private final ChunkAccess[] lastChunk = new ChunkAccess[4];
     private final List<LevelChunk> tickingChunks = new ArrayList<>();
     private final Set<ChunkHolder> chunkHoldersToBroadcast = new ReferenceOpenHashSet<>();
+    private static final int PLAYER_CHECK_INTERVAL = 10; // Ticks between full player checks
+    private int playerCheckCounter = 0;
+    private final it.unimi.dsi.fastutil.longs.Long2BooleanOpenHashMap chunkPlayerPresenceCache = new it.unimi.dsi.fastutil.longs.Long2BooleanOpenHashMap(256);
+    org.dreeam.leaf.util.quadtree.PlayerQuadtree.Rectangle2D worldBounds = new org.dreeam.leaf.util.quadtree.PlayerQuadtree.Rectangle2D(-30000000, -30000000, 60000000, 60000000);
+    org.dreeam.leaf.util.quadtree.PlayerQuadtree globalPlayerTree = new org.dreeam.leaf.util.quadtree.PlayerQuadtree(0, worldBounds);
+
     @Nullable
     @VisibleForDebug
     private NaturalSpawner.SpawnState lastSpawnState;
@@ -151,30 +157,41 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     // Paper end - rewrite chunk system
     // Paper start - chunk tick iteration optimisations
     private final net.minecraft.world.level.levelgen.BitRandomSource shuffleRandom = org.dreeam.leaf.config.modules.opt.FastRNG.enabled ? new org.dreeam.leaf.util.math.random.FasterRandomSource(0L) : new ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom(0L); // Leaf - Faster random generator
-    private boolean isChunkNearPlayer(final ChunkMap chunkMap, final ChunkPos chunkPos, final LevelChunk levelChunk) {
-        final ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkData chunkData = ((ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkSystemChunkHolder)((ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkSystemLevelChunk)levelChunk).moonrise$getChunkAndHolder().holder())
-            .moonrise$getRealChunkHolder().holderData;
-        final ca.spottedleaf.moonrise.common.misc.NearbyPlayers.TrackedChunk nearbyPlayers = chunkData.nearbyPlayers;
-        if (nearbyPlayers == null) {
-            return false;
-        }
-
-        final ca.spottedleaf.moonrise.common.list.ReferenceList<ServerPlayer> players = nearbyPlayers.getPlayers(ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.SPAWN_RANGE);
-
-        if (players == null) {
-            return false;
-        }
-
-        final ServerPlayer[] raw = players.getRawDataUnchecked();
-        final int len = players.size();
-
-        java.util.Objects.checkFromIndexSize(0, len, raw.length);
-        for (int i = 0; i < len; ++i) {
-            if (chunkMap.playerIsCloseEnoughForSpawning(raw[i], chunkPos, 16384.0D)) { // Spigot (reducedRange = false)
+    private boolean isChunkNearPlayer(ChunkMap chunkMap, final ChunkPos chunkPos, LevelChunk level) {
+        // Get chunk key directly from coordinates to avoid ChunkPos.toLong() call
+        final long chunkKey = ((long)chunkPos.x << 32) | (chunkPos.z & 0xFFFFFFFFL);
+        if (chunkPlayerPresenceCache.containsKey(chunkKey)) {
+            return chunkPlayerPresenceCache.get(chunkKey); // Use direct primitive access
+        }
+        // Pre-calculate block coordinates for chunk center once
+        final int blockX = SectionPos.sectionToBlockCoord(chunkPos.x, 8);
+        final int blockZ = SectionPos.sectionToBlockCoord(chunkPos.z, 8);
+        final int queryRadius = 128; // Make constant to avoid double conversion
+        org.dreeam.leaf.util.quadtree.PlayerQuadtree.Rectangle2D queryArea = new org.dreeam.leaf.util.quadtree.PlayerQuadtree.Rectangle2D(
+            blockX - queryRadius,
+            blockZ - queryRadius,
+            queryRadius << 1,
+            queryRadius << 1
+        );
+        // Pre-allocate list with expected size
+        List<ServerPlayer> candidates = new ArrayList<>(16);
+        globalPlayerTree.retrieve(candidates, queryArea);
+        // Use integer math where possible
+        final int radiusSquared = queryRadius * queryRadius;
+        for (int i = 0; i < candidates.size(); i++) {
+            ServerPlayer player = candidates.get(i);
+            if (!level.isInsideBuildHeight((int) player.getY())) {
+                continue;
+            }
+            // Use integer math for distance check
+            int dx = (int)(player.getX() - blockX);
+            int dz = (int)(player.getZ() - blockZ);
+            if (dx * dx + dz * dz < radiusSquared) {
+                chunkPlayerPresenceCache.put(chunkKey, true);
                 return true;
             }
         }
-
+        chunkPlayerPresenceCache.put(chunkKey, false);
         return false;
     }
     // Paper end - chunk tick iteration optimisations
@@ -477,6 +494,12 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
     @Override
     public void tick(BooleanSupplier hasTimeLeft, boolean tickChunks) {
+        playerCheckCounter++;
+        if (playerCheckCounter >= PLAYER_CHECK_INTERVAL) {
+            playerCheckCounter = 0;
+            chunkPlayerPresenceCache.clear();
+        }
+
         if (this.level.tickRateManager().runsNormally() || !tickChunks || this.level.spigotConfig.unloadFrozenChunks) { // Spigot
             this.distanceManager.purgeStaleTickets();
         }
@@ -749,15 +772,36 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
     public void move(ServerPlayer player) {
         if (!player.isRemoved()) {
+            // Remove from old position
+            globalPlayerTree.clear(); // Clear old position data
+
+            // Insert all players back into the quadtree with their current positions
+            for (ServerPlayer serverPlayer : this.level.players()) {
+                globalPlayerTree.insert(serverPlayer);
+            }
+
             this.chunkMap.move(player);
         }
     }
 
     public void removeEntity(Entity entity) {
+        if (entity instanceof ServerPlayer player) {
+            globalPlayerTree.clear(); // Remove old position
+
+            // Reinsert remaining players
+            for (ServerPlayer serverPlayer : this.level.players()) {
+                if (serverPlayer != player) {
+                    globalPlayerTree.insert(serverPlayer);
+                }
+            }
+        }
         this.chunkMap.removeEntity(entity);
     }
 
     public void addEntity(Entity entity) {
+        if (entity instanceof ServerPlayer player) {
+            globalPlayerTree.insert(player);
+        }
         this.chunkMap.addEntity(entity);
     }
 
