From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: HaHaWTH <102713261+HaHaWTH@users.noreply.github.com>
Date: Wed, 23 Oct 2024 23:54:00 +0800
Subject: [PATCH] Asynchronous locator

Original license: MIT
Original project: https://github.com/thebrightspark/AsyncLocator

diff --git a/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java b/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
index 217d1f908a36a5177ba3cbb80a33f73d4dab0fa0..da658e24ad6e10d6ce55cebf944871d3cbde7f4a 100644
--- a/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
@@ -80,6 +80,12 @@ public class TickThread extends Thread {
         this(null, run, name);
     }
 
+    // Leaf start - Async locator
+    public TickThread(final Runnable run, final String name, final int id) {
+        this(null, run, name, id);
+    }
+    // Leaf end - Async locator
+
     public TickThread(final ThreadGroup group, final Runnable run, final String name) {
         this(group, run, name, ID_GENERATOR.incrementAndGet());
     }
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
index 6676be8304e9415099ed423d3315180cafebd928..30b56382e9574004e344c1c8289d7dcbb177386b 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
@@ -48,6 +48,12 @@ class PaperEventManager {
                 return;
             }
             // Leaf end - Multithreaded tracker
+            // Leaf start - Async locator
+            if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled) {
+                net.minecraft.server.MinecraftServer.getServer().scheduleOnMain(event::callEvent);
+                return;
+            }
+            // Leaf end - Async locator
             throw new IllegalStateException(event.getEventName() + " may only be triggered synchronously.");
         }
         // Leaves start - skip photographer
diff --git a/net/minecraft/server/commands/LocateCommand.java b/net/minecraft/server/commands/LocateCommand.java
index dcdde4cd7f15d34eabba4b3802971db20e6ae9d2..e33f31ae83edc4e04ad1f3fa3216b90219d902dc 100644
--- a/net/minecraft/server/commands/LocateCommand.java
+++ b/net/minecraft/server/commands/LocateCommand.java
@@ -105,6 +105,37 @@ public class LocateCommand {
         BlockPos blockPos = BlockPos.containing(source.getPosition());
         ServerLevel serverLevel = source.getLevel();
         Stopwatch stopwatch = Stopwatch.createStarted(Util.TICKER);
+        // Leaf start - Async locator
+        if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled) {
+            net.minecraft.commands.CommandSource locatorSource = source.source;
+            if (locatorSource instanceof net.minecraft.server.level.ServerPlayer ||
+                locatorSource instanceof net.minecraft.server.MinecraftServer) {
+                BlockPos originPos = BlockPos.containing(source.getPosition());
+                org.dreeam.leaf.async.locate.AsyncLocator.locate(source.getLevel(), holderSet, originPos, 100, false)
+                        .thenOnServerThread(pair -> {
+                            stopwatch.stop();
+                            if (pair != null) {
+                                showLocateResult(
+                                        source,
+                                        predicate,
+                                        originPos,
+                                        pair,
+                                        "commands.locate.structure.success",
+                                        false,
+                                        stopwatch.elapsed()
+                                );
+                            } else {
+                                source.sendFailure(
+                                        Component.literal(
+                                                ERROR_STRUCTURE_NOT_FOUND.create(predicate.asPrintable()).getMessage()
+                                        )
+                                );
+                            }
+                        });
+                return 0;
+            }
+        }
+        // Leaf end - Async locator
         Pair<BlockPos, Holder<Structure>> pair = serverLevel.getChunkSource()
             .getGenerator()
             .findNearestMapStructure(serverLevel, holderSet, blockPos, 100, false);
diff --git a/net/minecraft/world/entity/animal/Dolphin.java b/net/minecraft/world/entity/animal/Dolphin.java
index c1842894f96a567707992d8ff938dbf689dd0df6..0792629152937b5107dbf444ce7f67e747f30c10 100644
--- a/net/minecraft/world/entity/animal/Dolphin.java
+++ b/net/minecraft/world/entity/animal/Dolphin.java
@@ -494,6 +494,8 @@ public class Dolphin extends AgeableWaterCreature {
 
         private final Dolphin dolphin;
         private boolean stuck;
+        @Nullable
+        private org.dreeam.leaf.async.locate.AsyncLocator.LocateTask<?> asyncLocator$locateTask;
 
         DolphinSwimToTreasureGoal(Dolphin dolphin) {
             this.dolphin = dolphin;
@@ -513,6 +515,11 @@ public class Dolphin extends AgeableWaterCreature {
 
         @Override
         public boolean canContinueToUse() {
+            // Leaf start - Async locator
+            if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled && this.asyncLocator$locateTask != null) {
+                return true;
+            }
+            // Leaf end - Async locator
             BlockPos blockposition = this.dolphin.getTreasurePos();
 
             return !BlockPos.containing((double) blockposition.getX(), this.dolphin.getY(), (double) blockposition.getZ()).closerToCenterThan(this.dolphin.position(), 4.0D) && !this.stuck && this.dolphin.getAirSupply() >= 100;
@@ -526,6 +533,21 @@ public class Dolphin extends AgeableWaterCreature {
                 this.stuck = false;
                 this.dolphin.getNavigation().stop();
                 BlockPos blockposition = this.dolphin.blockPosition();
+                // Leaf start - Async locator
+                if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled) {
+                    asyncLocator$locateTask = org.dreeam.leaf.async.locate.AsyncLocator.locate(worldserver, StructureTags.DOLPHIN_LOCATED, blockposition, 50, false)
+                            .thenOnServerThread(pos -> {
+                                asyncLocator$locateTask = null;
+                                if (pos != null) {
+                                    this.dolphin.setTreasurePos(pos);
+                                    worldserver.broadcastEntityEvent(this.dolphin, (byte) 38);
+                                } else {
+                                    this.stuck = true;
+                                }
+                            });
+                    return;
+                }
+                // Leaf end - Async locator
                 BlockPos blockposition1 = worldserver.findNearestMapStructure(StructureTags.DOLPHIN_LOCATED, blockposition, 50, false);
 
                 if (blockposition1 != null) {
@@ -539,6 +561,12 @@ public class Dolphin extends AgeableWaterCreature {
 
         @Override
         public void stop() {
+            // Leaf start - Async locator
+            if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled && this.asyncLocator$locateTask != null) {
+                this.asyncLocator$locateTask.cancel();
+                this.asyncLocator$locateTask = null;
+            }
+            // Leaf end - Async locator
             BlockPos blockposition = this.dolphin.getTreasurePos();
 
             if (BlockPos.containing((double) blockposition.getX(), this.dolphin.getY(), (double) blockposition.getZ()).closerToCenterThan(this.dolphin.position(), 4.0D) || this.stuck) {
@@ -549,6 +577,11 @@ public class Dolphin extends AgeableWaterCreature {
 
         @Override
         public void tick() {
+            // Leaf start - Async locator
+            if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled && this.asyncLocator$locateTask != null) {
+                return;
+            }
+            // Leaf end - Async locator
             Level world = this.dolphin.level();
 
             if (this.dolphin.closeToNextPos() || this.dolphin.getNavigation().isDone()) {
diff --git a/net/minecraft/world/entity/projectile/EyeOfEnder.java b/net/minecraft/world/entity/projectile/EyeOfEnder.java
index fd1f5de7dc151dfd187d23e022b2c5435ed8accc..35037b0d7d243d614aa6945330ae7186a6f20af5 100644
--- a/net/minecraft/world/entity/projectile/EyeOfEnder.java
+++ b/net/minecraft/world/entity/projectile/EyeOfEnder.java
@@ -30,6 +30,7 @@ public class EyeOfEnder extends Entity implements ItemSupplier {
     public double tz;
     public int life;
     public boolean surviveAfterDeath;
+    public boolean asyncLocator$locateTaskOngoing = false; // Leaf - Async locator
 
     public EyeOfEnder(EntityType<? extends EyeOfEnder> type, Level world) {
         super(type, world);
@@ -121,6 +122,11 @@ public class EyeOfEnder extends Entity implements ItemSupplier {
     @Override
     public void tick() {
         super.tick();
+        // Leaf start - Async locator
+        if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled && this.asyncLocator$locateTaskOngoing) {
+            return;
+        }
+        // Leaf end - Async locator
         Vec3 vec3d = this.getDeltaMovement();
         double d0 = this.getX() + vec3d.x;
         double d1 = this.getY() + vec3d.y;
diff --git a/net/minecraft/world/item/EnderEyeItem.java b/net/minecraft/world/item/EnderEyeItem.java
index c71a426c47e0ebc57ecb8c9c1d171737a084ccab..0edd6efc7a6dc7f62f07691fdd73fbb212c82173 100644
--- a/net/minecraft/world/item/EnderEyeItem.java
+++ b/net/minecraft/world/item/EnderEyeItem.java
@@ -113,7 +113,14 @@ public class EnderEyeItem extends Item {
             user.startUsingItem(hand);
             if (world instanceof ServerLevel) {
                 ServerLevel worldserver = (ServerLevel) world;
-                BlockPos blockposition = worldserver.findNearestMapStructure(StructureTags.EYE_OF_ENDER_LOCATED, user.blockPosition(), 100, false);
+                // Leaf start - Async locator
+                BlockPos blockposition;
+                if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled) {
+                    blockposition = BlockPos.ZERO;
+                } else {
+                    blockposition = worldserver.findNearestMapStructure(StructureTags.EYE_OF_ENDER_LOCATED, user.blockPosition(), 100, false);
+                }
+                // Leaf end - Async locator
 
                 if (blockposition == null) {
                     return InteractionResult.CONSUME;
@@ -121,8 +128,35 @@ public class EnderEyeItem extends Item {
 
                 EyeOfEnder entityendersignal = new EyeOfEnder(world, user.getX(), user.getY(0.5D), user.getZ());
 
+                // Leaf start - Async locator
+                final boolean isAsyncLocatorEnabled = org.dreeam.leaf.config.modules.async.AsyncLocator.enabled;
+                if (isAsyncLocatorEnabled) {
+                    entityendersignal.asyncLocator$locateTaskOngoing = true;
+                    org.dreeam.leaf.async.locate.AsyncLocator.locate(
+                            worldserver,
+                            StructureTags.EYE_OF_ENDER_LOCATED,
+                            user.blockPosition(),
+                            100,
+                            false
+                    ).thenOnServerThread(pos -> {
+                        entityendersignal.asyncLocator$locateTaskOngoing = false;
+                        if (pos != null) {
+                            entityendersignal.signalTo(pos);
+                            CriteriaTriggers.USED_ENDER_EYE.trigger((ServerPlayer) user, pos);
+                            user.awardStat(Stats.ITEM_USED.get(this));
+                        } else {
+                            // Set the entity's life to long enough that it dies
+                            entityendersignal.life = Integer.MAX_VALUE - 100;
+                        }
+                    });
+                }
+                // Leaf end - Async locator
                 entityendersignal.setItem(itemstack);
-                entityendersignal.signalTo(blockposition);
+                // Leaf start - Async locator
+                if (!isAsyncLocatorEnabled) {
+                    entityendersignal.signalTo(blockposition);
+                }
+                // Leaf end - Async locator
                 world.gameEvent((Holder) GameEvent.PROJECTILE_SHOOT, entityendersignal.position(), GameEvent.Context.of((Entity) user));
                 // CraftBukkit start
                 if (!world.addFreshEntity(entityendersignal)) {
@@ -139,7 +173,11 @@ public class EnderEyeItem extends Item {
 
                 world.playSound((Player) null, user.getX(), user.getY(), user.getZ(), SoundEvents.ENDER_EYE_LAUNCH, SoundSource.NEUTRAL, 1.0F, f);
                 itemstack.consume(1, user);
-                user.awardStat(Stats.ITEM_USED.get(this));
+                // Leaf start - Async locator
+                if (!isAsyncLocatorEnabled) {
+                    user.awardStat(Stats.ITEM_USED.get(this));
+                }
+                // Leaf end - Async locator
             }
 
             return InteractionResult.SUCCESS_SERVER;
