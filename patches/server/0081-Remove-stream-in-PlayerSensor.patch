From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: HaHaWTH <102713261+HaHaWTH@users.noreply.github.com>
Date: Tue, 9 Nov 2077 00:00:00 +0800
Subject: [PATCH] Remove stream in PlayerSensor

Stream operations in PlayerSensor take too much time
while ticking Villager farms, so just replace it with for loop =-=
Before: 164ms
After: 18ms

diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/PlayerSensor.java b/src/main/java/net/minecraft/world/entity/ai/sensing/PlayerSensor.java
index e1ff702e56adef6c8a572b078b49de2143c4ce7e..aa1a59bdaad5ac7b735524c3595a8589a92618cd 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/PlayerSensor.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/PlayerSensor.java
@@ -22,17 +22,39 @@ public class PlayerSensor extends Sensor<LivingEntity> {
 
     @Override
     protected void doTick(ServerLevel world, LivingEntity entity) {
-        List<Player> list = world.players()
-            .stream()
-            .filter(EntitySelector.NO_SPECTATORS)
-            .filter(player -> entity.closerThan(player, this.getFollowDistance(entity)))
-            .sorted(Comparator.comparingDouble(entity::distanceToSqr))
-            .collect(Collectors.toList());
+        // Leaf start - Remove stream in PlayerSensor
+        List<Player> list = new java.util.ArrayList<>();
+        for (Player player : world.players()) {
+            if (!EntitySelector.NO_SPECTATORS.test(player)) {
+                continue;
+            }
+            if (!entity.closerThan(player, this.getFollowDistance(entity))) {
+                continue;
+            }
+            list.add(player);
+        }
+        list.sort(Comparator.comparingDouble(entity::distanceToSqr));
+        // Leaf end - Remove stream in PlayerSensor
         Brain<?> brain = entity.getBrain();
         brain.setMemory(MemoryModuleType.NEAREST_PLAYERS, list);
-        List<Player> list2 = list.stream().filter(player -> isEntityTargetable(world, entity, player)).collect(Collectors.toList());
+        // Leaf start - Remove stream in PlayerSensor
+        List<Player> list2 = new java.util.ArrayList<>();
+        for (Player player : list) {
+            if (isEntityTargetable(world, entity, player)) {
+                list2.add(player);
+            }
+        }
+        // Leaf end - Remove stream in PlayerSensor
         brain.setMemory(MemoryModuleType.NEAREST_VISIBLE_PLAYER, list2.isEmpty() ? null : list2.get(0));
-        Optional<Player> optional = list2.stream().filter(player -> isEntityAttackable(world, entity, player)).findFirst();
+        // Leaf start - Remove stream in PlayerSensor
+        Optional<Player> optional = Optional.empty();
+        for (Player player : list2) {
+            if (isEntityAttackable(world, entity, player)) {
+                optional = Optional.of(player);
+                break;
+            }
+        }
+        // Leaf end - Remove stream in PlayerSensor
         brain.setMemory(MemoryModuleType.NEAREST_VISIBLE_ATTACKABLE_PLAYER, optional);
     }
 
