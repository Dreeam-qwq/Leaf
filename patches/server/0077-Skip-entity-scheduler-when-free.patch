From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: HaHaWTH <fsjk947@gmail.com>
Date: Wed, 13 Mar 2024 08:21:14 +0800
Subject: [PATCH] Skip-entity-scheduler-when-free


diff --git a/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java b/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
index 62484ebf4550b05182f693a3180bbac5d5fd906d..e288115ab79b26b0d139b6176475b2125456ec38 100644
--- a/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
+++ b/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
@@ -36,6 +36,7 @@ public final class EntityScheduler {
      * The Entity. Note that it is the CraftEntity, since only that class properly tracks world transfers.
      */
     public final CraftEntity entity;
+    public final net.minecraft.server.MinecraftServer server; // Leaf - skip EntityScheduler
 
     private static final record ScheduledTask(Consumer<? extends Entity> run, Consumer<? extends Entity> retired) {}
 
@@ -46,7 +47,8 @@ public final class EntityScheduler {
 
     private final ArrayDeque<ScheduledTask> currentlyExecuting = new ArrayDeque<>();
 
-    public EntityScheduler(final CraftEntity entity) {
+    public EntityScheduler(final net.minecraft.server.MinecraftServer server, final CraftEntity entity) { // Leaf - skip EntityScheduler
+        this.server = Validate.notNull(server);
         this.entity = Validate.notNull(entity);
     }
 
@@ -61,16 +63,17 @@ public final class EntityScheduler {
      * @throws IllegalStateException If the scheduler is already retired.
      */
     public void retire() {
+        final Entity thisEntity = this.entity.getHandleRaw(); // Leaf - skip EntityScheduler
         synchronized (this.stateLock) {
             if (this.tickCount == RETIRED_TICK_COUNT) {
                 throw new IllegalStateException("Already retired");
             }
             this.tickCount = RETIRED_TICK_COUNT;
+            this.server.entitiesWithScheduledTasks.remove(thisEntity); // Leaf - skip EntityScheduler
         }
 
-        final Entity thisEntity = this.entity.getHandleRaw();
+        // final Entity thisEntity = this.entity.getHandleRaw(); // Leaf - skip EntityScheduler
 
-        // correctly handle and order retiring while running executeTick
         for (int i = 0, len = this.currentlyExecuting.size(); i < len; ++i) {
             final ScheduledTask task = this.currentlyExecuting.pollFirst();
             final Consumer<Entity> retireTask = (Consumer<Entity>)task.retired;
@@ -124,6 +127,7 @@ public final class EntityScheduler {
             if (this.tickCount == RETIRED_TICK_COUNT) {
                 return false;
             }
+            this.server.entitiesWithScheduledTasks.add(this.entity.getHandleRaw()); // Leaf - skip EntityScheduler
             this.oneTimeDelayed.computeIfAbsent(this.tickCount + Math.max(1L, delay), (final long keyInMap) -> {
                 return new ArrayList<>();
             }).add(task);
@@ -143,6 +147,12 @@ public final class EntityScheduler {
         TickThread.ensureTickThread(thisEntity, "May not tick entity scheduler asynchronously");
         final List<ScheduledTask> toRun;
         synchronized (this.stateLock) {
+            // Leaf start - skip EntityScheduler
+            if (this.currentlyExecuting.isEmpty() && this.oneTimeDelayed.isEmpty()) {
+                this.server.entitiesWithScheduledTasks.remove(thisEntity);
+                return;
+            }
+            // Leaf end
             if (this.tickCount == RETIRED_TICK_COUNT) {
                 throw new IllegalStateException("Ticking retired scheduler");
             }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 754fff2c0305f2bf5ce1d080f0f0d9128a0fbb2e..5b2f894bb22c210d85a2ac5815962db969411a2b 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -299,7 +299,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public static final long SERVER_INIT = System.nanoTime(); // Paper - Lag compensation
 
     public gg.pufferfish.pufferfish.util.AsyncExecutor mobSpawnExecutor = new gg.pufferfish.pufferfish.util.AsyncExecutor("MobSpawning"); // Pufferfish - optimize mob spawning
-
+    public final Set<Entity> entitiesWithScheduledTasks = java.util.concurrent.ConcurrentHashMap.newKeySet(); // Leaf - skip EntityScheduler
+    
     public static <S extends MinecraftServer> S spin(Function<Thread, S> serverFactory) {
         AtomicReference<S> atomicreference = new AtomicReference();
         Thread thread = new io.papermc.paper.util.TickThread(() -> { // Paper - rewrite chunk system
@@ -1630,6 +1631,18 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.server.getScheduler().mainThreadHeartbeat(this.tickCount); // CraftBukkit
         // Paper start - Folia scheduler API
         ((io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler) Bukkit.getGlobalRegionScheduler()).tick();
+        // Leaf - skip EntityScheduler
+        for (final Entity entity : entitiesWithScheduledTasks) {
+            if (entity.isRemoved()) {
+                continue;
+            }
+
+            final org.bukkit.craftbukkit.entity.CraftEntity bukkit = entity.getBukkitEntityRaw();
+            if (bukkit != null) {
+                bukkit.taskScheduler.executeTick();
+            }
+        }
+        /*
         getAllLevels().forEach(level -> {
             for (final Entity entity : level.getEntityLookup().getAllCopy()) { // Paper - rewrite chunk system
                 if (entity.isRemoved()) {
@@ -1641,6 +1654,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 }
             }
         });
+        */
+        // Leaf end
         // Paper end - Folia scheduler API
         io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.CALLBACK_MANAGER.handleQueue(this.tickCount); // Paper
         this.getFunctions().tick();
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 897f9f5d25c674f167530810c0b94bca83c3c3cc..16c7889eb85a8ab3cd39907d54decad6381193fc 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -69,7 +69,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
     private final CraftPersistentDataContainer persistentDataContainer = new CraftPersistentDataContainer(CraftEntity.DATA_TYPE_REGISTRY);
     protected net.kyori.adventure.pointer.Pointers adventure$pointers; // Paper - implement pointers
     // Paper start - Folia shedulers
-    public final io.papermc.paper.threadedregions.EntityScheduler taskScheduler = new io.papermc.paper.threadedregions.EntityScheduler(this);
+    public final io.papermc.paper.threadedregions.EntityScheduler taskScheduler; // = new io.papermc.paper.threadedregions.EntityScheduler(this); // Leaf - skip EntityScheduler
     private final io.papermc.paper.threadedregions.scheduler.FoliaEntityScheduler apiScheduler = new io.papermc.paper.threadedregions.scheduler.FoliaEntityScheduler(this);
 
     @Override
@@ -82,6 +82,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         this.server = server;
         this.entity = entity;
         this.entityType = CraftEntityType.minecraftToBukkit(entity.getType());
+        this.taskScheduler = new io.papermc.paper.threadedregions.EntityScheduler(this.entity.getServer(), this); // Leaf - skip EntityScheduler
     }
 
     @Override
