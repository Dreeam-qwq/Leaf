From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: HaHaWTH <102713261+HaHaWTH@users.noreply.github.com>
Date: Wed, 23 Oct 2024 23:54:00 +0800
Subject: [PATCH] Asynchronous locator


diff --git a/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java b/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
index 11b7f15755dde766140c29bedca456c80d53293f..0b9a2448999826eef362589078688d6f5f69e4e6 100644
--- a/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
@@ -90,6 +90,13 @@ public class TickThread extends Thread {
     }
 
     public static boolean isTickThread() {
+        // Leaf start - Async locator
+        if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled) {
+            Thread currentThread = Thread.currentThread();
+            return currentThread instanceof TickThread ||
+                    currentThread instanceof org.dreeam.leaf.async.locate.AsyncLocator.AsyncLocatorThread;
+        }
+        // Leaf end - Async locator
         return Thread.currentThread() instanceof TickThread;
     }
 
diff --git a/src/main/java/net/minecraft/server/commands/LocateCommand.java b/src/main/java/net/minecraft/server/commands/LocateCommand.java
index 39f5deea47d8f573c3cfec5df431216ee806c32c..51994f272737f8754aac41dc0c55f43f45617519 100644
--- a/src/main/java/net/minecraft/server/commands/LocateCommand.java
+++ b/src/main/java/net/minecraft/server/commands/LocateCommand.java
@@ -106,6 +106,37 @@ public class LocateCommand {
         BlockPos blockPos = BlockPos.containing(source.getPosition());
         ServerLevel serverLevel = source.getLevel();
         Stopwatch stopwatch = Stopwatch.createStarted(Util.TICKER);
+        // Leaf start - Async locator
+        if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled) {
+            net.minecraft.commands.CommandSource locatorSource = source.source;
+            if (locatorSource instanceof net.minecraft.server.level.ServerPlayer ||
+                locatorSource instanceof net.minecraft.server.MinecraftServer) {
+                BlockPos originPos = BlockPos.containing(source.getPosition());
+                org.dreeam.leaf.async.locate.AsyncLocator.locate(source.getLevel(), holderSet, originPos, 100, false)
+                        .thenOnServerThread(pair -> {
+                            stopwatch.stop();
+                            if (pair != null) {
+                                showLocateResult(
+                                        source,
+                                        predicate,
+                                        originPos,
+                                        pair,
+                                        "commands.locate.structure.success",
+                                        false,
+                                        stopwatch.elapsed()
+                                );
+                            } else {
+                                source.sendFailure(
+                                        Component.literal(
+                                                ERROR_STRUCTURE_NOT_FOUND.create(predicate.asPrintable()).getMessage()
+                                        )
+                                );
+                            }
+                        });
+                return 0;
+            }
+        }
+        // Leaf end - Async locator
         Pair<BlockPos, Holder<Structure>> pair = serverLevel.getChunkSource()
             .getGenerator()
             .findNearestMapStructure(serverLevel, holderSet, blockPos, 100, false);
diff --git a/src/main/java/net/minecraft/world/entity/animal/Dolphin.java b/src/main/java/net/minecraft/world/entity/animal/Dolphin.java
index ef0124ceb7cafd58c01c7f0b4b542f38a383ab88..3646810c21641559ee81084da8ac290c720bd411 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Dolphin.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Dolphin.java
@@ -466,6 +466,8 @@ public class Dolphin extends WaterAnimal {
 
         private final Dolphin dolphin;
         private boolean stuck;
+        @Nullable
+        private org.dreeam.leaf.async.locate.AsyncLocator.LocateTask locateTask;
 
         DolphinSwimToTreasureGoal(Dolphin dolphin) {
             this.dolphin = dolphin;
@@ -485,6 +487,11 @@ public class Dolphin extends WaterAnimal {
 
         @Override
         public boolean canContinueToUse() {
+            // Leaf start - Async locator
+            if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled && this.locateTask != null) {
+                return true;
+            }
+            // Leaf end - Async locator
             BlockPos blockposition = this.dolphin.getTreasurePos();
 
             return !BlockPos.containing((double) blockposition.getX(), this.dolphin.getY(), (double) blockposition.getZ()).closerToCenterThan(this.dolphin.position(), 4.0D) && !this.stuck && this.dolphin.getAirSupply() >= 100;
@@ -498,6 +505,20 @@ public class Dolphin extends WaterAnimal {
                 this.stuck = false;
                 this.dolphin.getNavigation().stop();
                 BlockPos blockposition = this.dolphin.blockPosition();
+                // Leaf start - Async locator
+                if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled) {
+                    locateTask = org.dreeam.leaf.async.locate.AsyncLocator.locate(worldserver, StructureTags.DOLPHIN_LOCATED, blockposition, 50, false)
+                            .thenOnServerThread(pos -> {
+                                if (pos != null) {
+                                    this.dolphin.setTreasurePos(pos);
+                                    worldserver.broadcastEntityEvent(this.dolphin, (byte) 38);
+                                } else {
+                                    this.stuck = true;
+                                }
+                            });
+                    return;
+                }
+                // Leaf end - Async locator
                 BlockPos blockposition1 = worldserver.findNearestMapStructure(StructureTags.DOLPHIN_LOCATED, blockposition, 50, false);
 
                 if (blockposition1 != null) {
@@ -511,6 +532,12 @@ public class Dolphin extends WaterAnimal {
 
         @Override
         public void stop() {
+            // Leaf start - Async locator
+            if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled && this.locateTask != null) {
+                this.locateTask.cancel();
+                this.locateTask = null;
+            }
+            // Leaf end - Async locator
             BlockPos blockposition = this.dolphin.getTreasurePos();
 
             if (BlockPos.containing((double) blockposition.getX(), this.dolphin.getY(), (double) blockposition.getZ()).closerToCenterThan(this.dolphin.position(), 4.0D) || this.stuck) {
@@ -521,6 +548,11 @@ public class Dolphin extends WaterAnimal {
 
         @Override
         public void tick() {
+            // Leaf start - Async locator
+            if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled && this.locateTask != null) {
+                return;
+            }
+            // Leaf end - Async locator
             Level world = this.dolphin.level();
 
             if (this.dolphin.closeToNextPos() || this.dolphin.getNavigation().isDone()) {
diff --git a/src/main/java/org/dreeam/leaf/async/locate/AsyncLocator.java b/src/main/java/org/dreeam/leaf/async/locate/AsyncLocator.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab6fd96bb5a8fdbebf0d9a252fa4d17c6c37964e
--- /dev/null
+++ b/src/main/java/org/dreeam/leaf/async/locate/AsyncLocator.java
@@ -0,0 +1,150 @@
+package org.dreeam.leaf.async.locate;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import com.mojang.datafixers.util.Pair;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder;
+import net.minecraft.core.HolderSet;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.tags.TagKey;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.levelgen.structure.Structure;
+
+import java.util.concurrent.*;
+import java.util.function.Consumer;
+
+// Original project: https://github.com/thebrightspark/AsyncLocator
+public class AsyncLocator {
+    private static final ExecutorService LOCATING_EXECUTOR_SERVICE;
+
+    private AsyncLocator() {}
+
+    public static class AsyncLocatorThread extends Thread {
+    }
+
+    static {
+        int threads = org.dreeam.leaf.config.modules.async.AsyncLocator.asyncLocatorThreads;
+        LOCATING_EXECUTOR_SERVICE = Executors.newFixedThreadPool(
+                threads,
+                new ThreadFactoryBuilder()
+                        .setNameFormat("Leaf Async Locator Thread - %d")
+                        .setThreadFactory(
+                                r -> new AsyncLocatorThread() {
+                                    @Override
+                                    public void run() {
+                                        r.run();
+                                    }
+                                }
+                        )
+                        .setPriority(Thread.NORM_PRIORITY - 2)
+                        .build()
+        );
+    }
+
+    public static void shutdownExecutorService() {
+        if (LOCATING_EXECUTOR_SERVICE != null) {
+            LOCATING_EXECUTOR_SERVICE.shutdown();
+        }
+    }
+
+    /**
+     * Queues a task to locate a feature using {@link ServerLevel#findNearestMapStructure(TagKey, BlockPos, int, boolean)}
+     * and returns a {@link LocateTask} with the futures for it.
+     */
+    public static LocateTask<BlockPos> locate(
+            ServerLevel level,
+            TagKey<Structure> structureTag,
+            BlockPos pos,
+            int searchRadius,
+            boolean skipKnownStructures
+    ) {
+        CompletableFuture<BlockPos> completableFuture = new CompletableFuture<>();
+        Future<?> future = LOCATING_EXECUTOR_SERVICE.submit(
+                () -> doLocateLevel(completableFuture, level, structureTag, pos, searchRadius, skipKnownStructures)
+        );
+        return new LocateTask<>(level.getServer(), completableFuture, future);
+    }
+
+    /**
+     * Queues a task to locate a feature using
+     * {@link ChunkGenerator#findNearestMapStructure(ServerLevel, HolderSet, BlockPos, int, boolean)} and returns a
+     * {@link LocateTask} with the futures for it.
+     */
+    public static LocateTask<Pair<BlockPos, Holder<Structure>>> locate(
+            ServerLevel level,
+            HolderSet<Structure> structureSet,
+            BlockPos pos,
+            int searchRadius,
+            boolean skipKnownStructures
+    ) {
+        CompletableFuture<Pair<BlockPos, Holder<Structure>>> completableFuture = new CompletableFuture<>();
+        Future<?> future = LOCATING_EXECUTOR_SERVICE.submit(
+                () -> doLocateChunkGenerator(completableFuture, level, structureSet, pos, searchRadius, skipKnownStructures)
+        );
+        return new LocateTask<>(level.getServer(), completableFuture, future);
+    }
+
+    private static void doLocateLevel(
+            CompletableFuture<BlockPos> completableFuture,
+            ServerLevel level,
+            TagKey<Structure> structureTag,
+            BlockPos pos,
+            int searchRadius,
+            boolean skipExistingChunks
+    ) {
+        BlockPos foundPos = level.findNearestMapStructure(structureTag, pos, searchRadius, skipExistingChunks);
+        completableFuture.complete(foundPos);
+    }
+
+    private static void doLocateChunkGenerator(
+            CompletableFuture<Pair<BlockPos, Holder<Structure>>> completableFuture,
+            ServerLevel level,
+            HolderSet<Structure> structureSet,
+            BlockPos pos,
+            int searchRadius,
+            boolean skipExistingChunks
+    ) {
+        long start = System.nanoTime();
+        Pair<BlockPos, Holder<Structure>> foundPair = level.getChunkSource().getGenerator()
+                .findNearestMapStructure(level, structureSet, pos, searchRadius, skipExistingChunks);
+        completableFuture.complete(foundPair);
+    }
+
+    /**
+     * Holder of the futures for an async locate task as well as providing some helper functions.
+     * The completableFuture will be completed once the call to
+     * {@link ServerLevel#findNearestMapStructure(TagKey, BlockPos, int, boolean)} has completed, and will hold the
+     * result of it.
+     * The taskFuture is the future for the {@link Runnable} itself in the executor service.
+     */
+    public record LocateTask<T>(MinecraftServer server, CompletableFuture<T> completableFuture, Future<?> taskFuture) {
+        /**
+         * Helper function that calls {@link CompletableFuture#thenAccept(Consumer)} with the given action.
+         * Bear in mind that the action will be executed from the task's thread. If you intend to change any game data,
+         * it's strongly advised you use {@link #thenOnServerThread(Consumer)} instead so that it's queued and executed
+         * on the main server thread instead.
+         */
+        public LocateTask<T> then(Consumer<T> action) {
+            completableFuture.thenAccept(action);
+            return this;
+        }
+
+        /**
+         * Helper function that calls {@link CompletableFuture#thenAccept(Consumer)} with the given action on the server
+         * thread.
+         */
+        public LocateTask<T> thenOnServerThread(Consumer<T> action) {
+            completableFuture.thenAccept(pos -> server.submit(() -> action.accept(pos)));
+            return this;
+        }
+
+        /**
+         * Helper function that cancels both completableFuture and taskFuture.
+         */
+        public void cancel() {
+            taskFuture.cancel(true);
+            completableFuture.cancel(false);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/dreeam/leaf/config/modules/async/AsyncLocator.java b/src/main/java/org/dreeam/leaf/config/modules/async/AsyncLocator.java
new file mode 100644
index 0000000000000000000000000000000000000000..9c02fab33892ba0711b1cf7d63e343591173bdfd
--- /dev/null
+++ b/src/main/java/org/dreeam/leaf/config/modules/async/AsyncLocator.java
@@ -0,0 +1,35 @@
+package org.dreeam.leaf.config.modules.async;
+
+import org.dreeam.leaf.config.ConfigModules;
+import org.dreeam.leaf.config.EnumConfigCategory;
+import org.dreeam.leaf.config.LeafConfig;
+
+public class AsyncLocator extends ConfigModules {
+
+    public String getBasePath() {
+        return EnumConfigCategory.ASYNC.getBaseKeyName() + ".async-locator";
+    }
+
+    public static boolean enabled = false;
+    public static int asyncLocatorThreads = 0;
+
+    @Override
+    public void onLoaded() {
+        config.addComment(getBasePath(), """
+                ***Experimental feature, report any bugs you encountered!***
+                Whether or not asynchronous locator should be enabled.
+                This offloads structure locating to other threads.
+                Only for locate command and dolphin treasure finding currently.""");
+        enabled = config.getBoolean(getBasePath() + ".enabled", enabled);
+        asyncLocatorThreads = config.getInt(getBasePath() + ".threads", asyncLocatorThreads);
+
+        if (asyncLocatorThreads < 0)
+            asyncLocatorThreads = Math.max(Runtime.getRuntime().availableProcessors() + asyncLocatorThreads, 1);
+        else if (asyncLocatorThreads == 0)
+            asyncLocatorThreads = Math.max(Runtime.getRuntime().availableProcessors() / 4, 1);
+        if (!enabled)
+            asyncLocatorThreads = 0;
+        else
+            LeafConfig.LOGGER.info("Using {} threads for Async Locator", asyncLocatorThreads);
+    }
+}
