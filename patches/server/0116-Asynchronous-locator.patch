From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: HaHaWTH <102713261+HaHaWTH@users.noreply.github.com>
Date: Wed, 23 Oct 2024 23:54:00 +0800
Subject: [PATCH] Asynchronous locator

This patch was ported from project: https://github.com/thebrightspark/AsyncLocator

diff --git a/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java b/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
index 11b7f15755dde766140c29bedca456c80d53293f..749d00449ac3f3c79bfc73a5517ea3a07675e447 100644
--- a/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
@@ -80,7 +80,7 @@ public class TickThread extends Thread {
         this(run, name, ID_GENERATOR.incrementAndGet());
     }
 
-    private TickThread(final Runnable run, final String name, final int id) {
+    protected TickThread(final Runnable run, final String name, final int id) { // Leaf - private -> protected
         super(run, name);
         this.id = id;
     }
diff --git a/src/main/java/net/minecraft/server/commands/LocateCommand.java b/src/main/java/net/minecraft/server/commands/LocateCommand.java
index 39f5deea47d8f573c3cfec5df431216ee806c32c..51994f272737f8754aac41dc0c55f43f45617519 100644
--- a/src/main/java/net/minecraft/server/commands/LocateCommand.java
+++ b/src/main/java/net/minecraft/server/commands/LocateCommand.java
@@ -106,6 +106,37 @@ public class LocateCommand {
         BlockPos blockPos = BlockPos.containing(source.getPosition());
         ServerLevel serverLevel = source.getLevel();
         Stopwatch stopwatch = Stopwatch.createStarted(Util.TICKER);
+        // Leaf start - Async locator
+        if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled) {
+            net.minecraft.commands.CommandSource locatorSource = source.source;
+            if (locatorSource instanceof net.minecraft.server.level.ServerPlayer ||
+                locatorSource instanceof net.minecraft.server.MinecraftServer) {
+                BlockPos originPos = BlockPos.containing(source.getPosition());
+                org.dreeam.leaf.async.locate.AsyncLocator.locate(source.getLevel(), holderSet, originPos, 100, false)
+                        .thenOnServerThread(pair -> {
+                            stopwatch.stop();
+                            if (pair != null) {
+                                showLocateResult(
+                                        source,
+                                        predicate,
+                                        originPos,
+                                        pair,
+                                        "commands.locate.structure.success",
+                                        false,
+                                        stopwatch.elapsed()
+                                );
+                            } else {
+                                source.sendFailure(
+                                        Component.literal(
+                                                ERROR_STRUCTURE_NOT_FOUND.create(predicate.asPrintable()).getMessage()
+                                        )
+                                );
+                            }
+                        });
+                return 0;
+            }
+        }
+        // Leaf end - Async locator
         Pair<BlockPos, Holder<Structure>> pair = serverLevel.getChunkSource()
             .getGenerator()
             .findNearestMapStructure(serverLevel, holderSet, blockPos, 100, false);
diff --git a/src/main/java/net/minecraft/world/entity/animal/Dolphin.java b/src/main/java/net/minecraft/world/entity/animal/Dolphin.java
index ef0124ceb7cafd58c01c7f0b4b542f38a383ab88..3646810c21641559ee81084da8ac290c720bd411 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Dolphin.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Dolphin.java
@@ -466,6 +466,8 @@ public class Dolphin extends WaterAnimal {
 
         private final Dolphin dolphin;
         private boolean stuck;
+        @Nullable
+        private org.dreeam.leaf.async.locate.AsyncLocator.LocateTask locateTask;
 
         DolphinSwimToTreasureGoal(Dolphin dolphin) {
             this.dolphin = dolphin;
@@ -485,6 +487,11 @@ public class Dolphin extends WaterAnimal {
 
         @Override
         public boolean canContinueToUse() {
+            // Leaf start - Async locator
+            if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled && this.locateTask != null) {
+                return true;
+            }
+            // Leaf end - Async locator
             BlockPos blockposition = this.dolphin.getTreasurePos();
 
             return !BlockPos.containing((double) blockposition.getX(), this.dolphin.getY(), (double) blockposition.getZ()).closerToCenterThan(this.dolphin.position(), 4.0D) && !this.stuck && this.dolphin.getAirSupply() >= 100;
@@ -498,6 +505,20 @@ public class Dolphin extends WaterAnimal {
                 this.stuck = false;
                 this.dolphin.getNavigation().stop();
                 BlockPos blockposition = this.dolphin.blockPosition();
+                // Leaf start - Async locator
+                if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled) {
+                    locateTask = org.dreeam.leaf.async.locate.AsyncLocator.locate(worldserver, StructureTags.DOLPHIN_LOCATED, blockposition, 50, false)
+                            .thenOnServerThread(pos -> {
+                                if (pos != null) {
+                                    this.dolphin.setTreasurePos(pos);
+                                    worldserver.broadcastEntityEvent(this.dolphin, (byte) 38);
+                                } else {
+                                    this.stuck = true;
+                                }
+                            });
+                    return;
+                }
+                // Leaf end - Async locator
                 BlockPos blockposition1 = worldserver.findNearestMapStructure(StructureTags.DOLPHIN_LOCATED, blockposition, 50, false);
 
                 if (blockposition1 != null) {
@@ -511,6 +532,12 @@ public class Dolphin extends WaterAnimal {
 
         @Override
         public void stop() {
+            // Leaf start - Async locator
+            if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled && this.locateTask != null) {
+                this.locateTask.cancel();
+                this.locateTask = null;
+            }
+            // Leaf end - Async locator
             BlockPos blockposition = this.dolphin.getTreasurePos();
 
             if (BlockPos.containing((double) blockposition.getX(), this.dolphin.getY(), (double) blockposition.getZ()).closerToCenterThan(this.dolphin.position(), 4.0D) || this.stuck) {
@@ -521,6 +548,11 @@ public class Dolphin extends WaterAnimal {
 
         @Override
         public void tick() {
+            // Leaf start - Async locator
+            if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled && this.locateTask != null) {
+                return;
+            }
+            // Leaf end - Async locator
             Level world = this.dolphin.level();
 
             if (this.dolphin.closeToNextPos() || this.dolphin.getNavigation().isDone()) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
index 00ed0d5ad535faa36111ab28bb0cf1317eb067ec..b5a2a384c4113dff49507eb686dd21292a6a1321 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
@@ -132,12 +132,35 @@ public abstract class ChunkGenerator {
         final List<org.bukkit.generator.structure.Structure> apiStructures = structures.stream().map(Holder::value).map(nms -> org.bukkit.craftbukkit.generator.structure.CraftStructure.minecraftToBukkit(nms)).toList();
         if (!apiStructures.isEmpty()) {
             final io.papermc.paper.event.world.StructuresLocateEvent event = new io.papermc.paper.event.world.StructuresLocateEvent(bukkitWorld, origin, apiStructures, radius, skipReferencedStructures);
-            if (!event.callEvent()) {
-                return null;
-            }
-            if (event.getResult() != null) {
-                return Pair.of(io.papermc.paper.util.MCUtil.toBlockPos(event.getResult().pos()), world.registryAccess().registryOrThrow(Registries.STRUCTURE).wrapAsHolder(org.bukkit.craftbukkit.generator.structure.CraftStructure.bukkitToMinecraft(event.getResult().structure())));
+            // Leaf start - Async locator - Ensure event is called on server thread
+            if (org.dreeam.leaf.config.modules.async.AsyncLocator.enabled &&
+                    Thread.currentThread() instanceof org.dreeam.leaf.async.locate.AsyncLocator.AsyncLocatorThread) {
+                final java.util.concurrent.atomic.AtomicBoolean shouldReturn = new java.util.concurrent.atomic.AtomicBoolean(true);
+                CompletableFuture<Pair<BlockPos, Holder<Structure>>> futureEvent = net.minecraft.server.MinecraftServer.getServer().submit(() -> {
+                    if (!event.callEvent()) {
+                        shouldReturn.set(true);
+                        return null;
+                    }
+                    if (event.getResult() != null) {
+                        shouldReturn.set(true);
+                        return Pair.of(io.papermc.paper.util.MCUtil.toBlockPos(event.getResult().pos()), world.registryAccess().registryOrThrow(Registries.STRUCTURE).wrapAsHolder(org.bukkit.craftbukkit.generator.structure.CraftStructure.bukkitToMinecraft(event.getResult().structure())));
+                    }
+                    shouldReturn.set(false);
+                    return null;
+                });
+                Pair<BlockPos, Holder<Structure>> result = futureEvent.join();
+                if (shouldReturn.get()) {
+                    return result;
+                }
+            } else {
+                if (!event.callEvent()) {
+                    return null;
+                }
+                if (event.getResult() != null) {
+                    return Pair.of(io.papermc.paper.util.MCUtil.toBlockPos(event.getResult().pos()), world.registryAccess().registryOrThrow(Registries.STRUCTURE).wrapAsHolder(org.bukkit.craftbukkit.generator.structure.CraftStructure.bukkitToMinecraft(event.getResult().structure())));
+                }
             }
+            // Leaf end - Async locator - Ensure event is called on server thread
             center = io.papermc.paper.util.MCUtil.toBlockPosition(event.getOrigin());
             radius = event.getRadius();
             skipReferencedStructures = event.shouldFindUnexplored();
diff --git a/src/main/java/org/dreeam/leaf/async/locate/AsyncLocator.java b/src/main/java/org/dreeam/leaf/async/locate/AsyncLocator.java
new file mode 100644
index 0000000000000000000000000000000000000000..b03c908d1e630d08ba91279886d244977e9de4b6
--- /dev/null
+++ b/src/main/java/org/dreeam/leaf/async/locate/AsyncLocator.java
@@ -0,0 +1,161 @@
+package org.dreeam.leaf.async.locate;
+
+import ca.spottedleaf.moonrise.common.util.TickThread;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import com.mojang.datafixers.util.Pair;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder;
+import net.minecraft.core.HolderSet;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.tags.TagKey;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.levelgen.structure.Structure;
+
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Consumer;
+
+// Original project: https://github.com/thebrightspark/AsyncLocator
+public class AsyncLocator {
+    private static final ExecutorService LOCATING_EXECUTOR_SERVICE;
+
+    private AsyncLocator() {}
+
+    public static class AsyncLocatorThread extends TickThread {
+        private static final AtomicInteger THREAD_COUNTER = new AtomicInteger(0);
+        public AsyncLocatorThread(Runnable run, String name) {
+            super(run, name, THREAD_COUNTER.incrementAndGet());
+        }
+
+        @Override
+        public void run() {
+            super.run();
+        }
+    }
+
+    static {
+        int threads = org.dreeam.leaf.config.modules.async.AsyncLocator.asyncLocatorThreads;
+        LOCATING_EXECUTOR_SERVICE = Executors.newFixedThreadPool(
+                threads,
+                new ThreadFactoryBuilder()
+                        .setThreadFactory(
+                                r -> new AsyncLocatorThread(r, "Leaf Async Locator Thread") {
+                                    @Override
+                                    public void run() {
+                                        r.run();
+                                    }
+                                }
+                        )
+                        .setNameFormat("Leaf Async Locator Thread - %d")
+                        .setPriority(Thread.NORM_PRIORITY - 2)
+                        .build()
+        );
+    }
+
+    public static void shutdownExecutorService() {
+        if (LOCATING_EXECUTOR_SERVICE != null) {
+            LOCATING_EXECUTOR_SERVICE.shutdown();
+        }
+    }
+
+    /**
+     * Queues a task to locate a feature using {@link ServerLevel#findNearestMapStructure(TagKey, BlockPos, int, boolean)}
+     * and returns a {@link LocateTask} with the futures for it.
+     */
+    public static LocateTask<BlockPos> locate(
+            ServerLevel level,
+            TagKey<Structure> structureTag,
+            BlockPos pos,
+            int searchRadius,
+            boolean skipKnownStructures
+    ) {
+        CompletableFuture<BlockPos> completableFuture = new CompletableFuture<>();
+        Future<?> future = LOCATING_EXECUTOR_SERVICE.submit(
+                () -> doLocateLevel(completableFuture, level, structureTag, pos, searchRadius, skipKnownStructures)
+        );
+        return new LocateTask<>(level.getServer(), completableFuture, future);
+    }
+
+    /**
+     * Queues a task to locate a feature using
+     * {@link ChunkGenerator#findNearestMapStructure(ServerLevel, HolderSet, BlockPos, int, boolean)} and returns a
+     * {@link LocateTask} with the futures for it.
+     */
+    public static LocateTask<Pair<BlockPos, Holder<Structure>>> locate(
+            ServerLevel level,
+            HolderSet<Structure> structureSet,
+            BlockPos pos,
+            int searchRadius,
+            boolean skipKnownStructures
+    ) {
+        CompletableFuture<Pair<BlockPos, Holder<Structure>>> completableFuture = new CompletableFuture<>();
+        Future<?> future = LOCATING_EXECUTOR_SERVICE.submit(
+                () -> doLocateChunkGenerator(completableFuture, level, structureSet, pos, searchRadius, skipKnownStructures)
+        );
+        return new LocateTask<>(level.getServer(), completableFuture, future);
+    }
+
+    private static void doLocateLevel(
+            CompletableFuture<BlockPos> completableFuture,
+            ServerLevel level,
+            TagKey<Structure> structureTag,
+            BlockPos pos,
+            int searchRadius,
+            boolean skipExistingChunks
+    ) {
+        BlockPos foundPos = level.findNearestMapStructure(structureTag, pos, searchRadius, skipExistingChunks);
+        completableFuture.complete(foundPos);
+    }
+
+    private static void doLocateChunkGenerator(
+            CompletableFuture<Pair<BlockPos, Holder<Structure>>> completableFuture,
+            ServerLevel level,
+            HolderSet<Structure> structureSet,
+            BlockPos pos,
+            int searchRadius,
+            boolean skipExistingChunks
+    ) {
+        Pair<BlockPos, Holder<Structure>> foundPair = level.getChunkSource().getGenerator()
+                .findNearestMapStructure(level, structureSet, pos, searchRadius, skipExistingChunks);
+        completableFuture.complete(foundPair);
+    }
+
+    /**
+     * Holder of the futures for an async locate task as well as providing some helper functions.
+     * The completableFuture will be completed once the call to
+     * {@link ServerLevel#findNearestMapStructure(TagKey, BlockPos, int, boolean)} has completed, and will hold the
+     * result of it.
+     * The taskFuture is the future for the {@link Runnable} itself in the executor service.
+     */
+    public record LocateTask<T>(MinecraftServer server, CompletableFuture<T> completableFuture, Future<?> taskFuture) {
+        /**
+         * Helper function that calls {@link CompletableFuture#thenAccept(Consumer)} with the given action.
+         * Bear in mind that the action will be executed from the task's thread. If you intend to change any game data,
+         * it's strongly advised you use {@link #thenOnServerThread(Consumer)} instead so that it's queued and executed
+         * on the main server thread instead.
+         */
+        public LocateTask<T> then(Consumer<T> action) {
+            completableFuture.thenAccept(action);
+            return this;
+        }
+
+        /**
+         * Helper function that calls {@link CompletableFuture#thenAccept(Consumer)} with the given action on the server
+         * thread.
+         */
+        public LocateTask<T> thenOnServerThread(Consumer<T> action) {
+            // noinspection ResultOfMethodCallIgnored
+            completableFuture.thenAccept(pos -> server.submit(() -> action.accept(pos)));
+            return this;
+        }
+
+        /**
+         * Helper function that cancels both completableFuture and taskFuture.
+         */
+        public void cancel() {
+            taskFuture.cancel(true);
+            completableFuture.cancel(false);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/dreeam/leaf/config/modules/async/AsyncLocator.java b/src/main/java/org/dreeam/leaf/config/modules/async/AsyncLocator.java
new file mode 100644
index 0000000000000000000000000000000000000000..9c02fab33892ba0711b1cf7d63e343591173bdfd
--- /dev/null
+++ b/src/main/java/org/dreeam/leaf/config/modules/async/AsyncLocator.java
@@ -0,0 +1,35 @@
+package org.dreeam.leaf.config.modules.async;
+
+import org.dreeam.leaf.config.ConfigModules;
+import org.dreeam.leaf.config.EnumConfigCategory;
+import org.dreeam.leaf.config.LeafConfig;
+
+public class AsyncLocator extends ConfigModules {
+
+    public String getBasePath() {
+        return EnumConfigCategory.ASYNC.getBaseKeyName() + ".async-locator";
+    }
+
+    public static boolean enabled = false;
+    public static int asyncLocatorThreads = 0;
+
+    @Override
+    public void onLoaded() {
+        config.addComment(getBasePath(), """
+                ***Experimental feature, report any bugs you encountered!***
+                Whether or not asynchronous locator should be enabled.
+                This offloads structure locating to other threads.
+                Only for locate command and dolphin treasure finding currently.""");
+        enabled = config.getBoolean(getBasePath() + ".enabled", enabled);
+        asyncLocatorThreads = config.getInt(getBasePath() + ".threads", asyncLocatorThreads);
+
+        if (asyncLocatorThreads < 0)
+            asyncLocatorThreads = Math.max(Runtime.getRuntime().availableProcessors() + asyncLocatorThreads, 1);
+        else if (asyncLocatorThreads == 0)
+            asyncLocatorThreads = Math.max(Runtime.getRuntime().availableProcessors() / 4, 1);
+        if (!enabled)
+            asyncLocatorThreads = 0;
+        else
+            LeafConfig.LOGGER.info("Using {} threads for Async Locator", asyncLocatorThreads);
+    }
+}
