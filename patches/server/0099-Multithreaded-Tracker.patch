From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: peaches94 <peachescu94@gmail.com>
Date: Sat, 2 Jul 2022 00:35:56 -0500
Subject: [PATCH] Multithreaded Tracker

TODO:
- Check and fix compatibility with npc/fake player

And issues waiting to check:
https://github.com/Bloom-host/Petal/issues/26
https://github.com/Bloom-host/Petal/issues/23
https://github.com/Bloom-host/Petal/issues/12
https://github.com/Bloom-host/Petal/issues/11
https://github.com/Bloom-host/Petal/issues/5
https://github.com/Bloom-host/Petal/issues/3

Original code by Bloom-host, licensed under GPL v3
You can find the original code on https://github.com/Bloom-host/Petal

This patch was ported downstream from the Petal fork, and is derived from
the Airplane fork by Paul Sauve

Based off the Airplane multithreaded tracker, this patch properly handles
concurrent accesses everywhere, as well as being much simpler to maintain

Some things are too unsafe to run off the main thread so we don't attempt to do
that. This multithreaded tracker remains accurate, non-breaking and fast.

diff --git a/src/main/java/ca/spottedleaf/moonrise/common/list/IteratorSafeOrderedReferenceSet.java b/src/main/java/ca/spottedleaf/moonrise/common/list/IteratorSafeOrderedReferenceSet.java
index c21e00812f1aaa1279834a0562d360d6b89e146c..cb4c6cb7b20a342af81ebfedc3551d61212ba3d5 100644
--- a/src/main/java/ca/spottedleaf/moonrise/common/list/IteratorSafeOrderedReferenceSet.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/list/IteratorSafeOrderedReferenceSet.java
@@ -14,7 +14,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
 
     /* list impl */
     private E[] listElements;
-    private int listSize;
+    private int listSize; public int getListSize() { return this.listSize; } // Leaf - petal - expose listSize
 
     private final double maxFragFactor;
 
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
index 1260b9abca3d194507f3f982add32ef01adcbcd7..20653152de94298a3112d5329fb1013110f0295e 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
@@ -40,7 +40,7 @@ public final class ChunkEntitySlices {
     private final EntityCollectionBySection hardCollidingEntities;
     private final Reference2ObjectOpenHashMap<Class<? extends Entity>, EntityCollectionBySection> entitiesByClass;
     private final Reference2ObjectOpenHashMap<EntityType<?>, EntityCollectionBySection> entitiesByType;
-    private final EntityList entities = new EntityList();
+    public final EntityList entities = new EntityList(); // Leaf - petal - protected -> public
 
     public FullChunkStatus status;
 
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
index 6994db535d8d39a73ce54da5b7a03b579323f4a8..dadc5ee6a79a47cbebcc8e8c943c2147cc16d732 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
@@ -46,6 +46,12 @@ class PaperEventManager {
         if (isAsync && onPrimaryThread) {
             throw new IllegalStateException(event.getEventName() + " may only be triggered asynchronously.");
         } else if (!isAsync && !onPrimaryThread && !this.server.isStopping()) {
+            // Leaf start - petal
+            if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled) {
+                net.minecraft.server.MinecraftServer.getServer().scheduleOnMain(event::callEvent);
+                return;
+            }
+            // Leaf end - petal
             throw new IllegalStateException(event.getEventName() + " may only be triggered synchronously.");
         }
         // KTP stop - Optimise spigot event bus
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 200a08d09904c6d5ea85b9e2c0228e6184f3aed1..cb25d45a5fe32977a7beb2b852c0ff535abd43ac 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -906,6 +906,20 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$setTrackedEntity(null); // Paper - optimise entity tracker
     }
 
+    // Leaf start - petal - multithreaded tracker
+    private @Nullable org.dreeam.leaf.async.tracker.MultithreadedTracker multithreadedTracker;
+    private final java.util.concurrent.ConcurrentLinkedQueue<Runnable> trackerMainThreadTasks = new java.util.concurrent.ConcurrentLinkedQueue<>();
+    private boolean tracking = false;
+
+    public void runOnTrackerMainThread(final Runnable runnable) {
+        if (false && this.tracking) {
+            this.trackerMainThreadTasks.add(runnable);
+        } else {
+            runnable.run();
+        }
+    }
+    // Leaf end - petal - multithreaded tracker
+
     // Paper start - optimise entity tracker
     private void newTrackerTick() {
         final ca.spottedleaf.moonrise.common.misc.NearbyPlayers nearbyPlayers = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getNearbyPlayers();
@@ -915,6 +929,9 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         final Entity[] trackerEntitiesRaw = trackerEntities.getRawDataUnchecked();
         for (int i = 0, len = trackerEntities.size(); i < len; ++i) {
             final Entity entity = trackerEntitiesRaw[i];
+            if (entity == null) {
+                continue;
+            }
             final ChunkMap.TrackedEntity tracker = ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$getTrackedEntity();
             if (tracker == null) {
                 continue;
@@ -939,6 +956,12 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Paper end - optimise entity tracker
 
     protected void tick() {
+        // Leaf start - petal - multithreaded tracker
+        if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled) {
+            org.dreeam.leaf.async.tracker.MultithreadedTracker.tick(this::newTrackerTick);
+            return;
+        }
+        // Leaf end - petal - multithreaded tracker
         // Paper start - optimise entity tracker
         if (true) {
             this.newTrackerTick();
@@ -1085,10 +1108,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public class TrackedEntity implements ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity { // Paper - optimise entity tracker
 
         public final ServerEntity serverEntity;
-        final Entity entity;
+        public final Entity entity; // Leaf - petal - public
         private final int range;
         SectionPos lastSectionPos;
-        public final Set<ServerPlayerConnection> seenBy = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>(); // Paper - Perf: optimise map impl
+        public final Set<ServerPlayerConnection> seenBy = Sets.newConcurrentHashSet(); // Paper - Perf: optimise map impl // Leaf - Fix tracker NPE
 
         // Paper start - optimise entity tracker
         private long lastChunkUpdate = -1L;
@@ -1184,14 +1207,11 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         public void broadcast(Packet<?> packet) {
-            Iterator iterator = this.seenBy.iterator();
-
-            while (iterator.hasNext()) {
-                ServerPlayerConnection serverplayerconnection = (ServerPlayerConnection) iterator.next();
-
+            // Leaf start - petal - avoid NPE
+            for (ServerPlayerConnection serverplayerconnection : this.seenBy.toArray(new ServerPlayerConnection[0])) {
                 serverplayerconnection.send(packet);
             }
-
+            // Leaf end - petal
         }
 
         public void broadcastAndSend(Packet<?> packet) {
@@ -1203,18 +1223,15 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         public void broadcastRemoved() {
-            Iterator iterator = this.seenBy.iterator();
-
-            while (iterator.hasNext()) {
-                ServerPlayerConnection serverplayerconnection = (ServerPlayerConnection) iterator.next();
-
+            // Leaf start - petal - avoid NPE
+            for (ServerPlayerConnection serverplayerconnection : this.seenBy.toArray(new ServerPlayerConnection[0])) {
                 this.serverEntity.removePairing(serverplayerconnection.getPlayer());
             }
-
+            // Leaf end - petal
         }
 
         public void removePlayer(ServerPlayer player) {
-            org.spigotmc.AsyncCatcher.catchOp("player tracker clear"); // Spigot
+            //org.spigotmc.AsyncCatcher.catchOp("player tracker clear"); // Spigot // Leaf - petal - We can remove async too
             if (this.seenBy.remove(player.connection)) {
                 this.serverEntity.removePairing(player);
             }
@@ -1222,7 +1239,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         public void updatePlayer(ServerPlayer player) {
-            org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
+            //org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot // Leaf - petal - We can update async
             if (player != this.entity) {
                 // Paper start - remove allocation of Vec3D here
                 // Vec3 vec3d = player.position().subtract(this.entity.position());
diff --git a/src/main/java/net/minecraft/server/level/ServerBossEvent.java b/src/main/java/net/minecraft/server/level/ServerBossEvent.java
index 4f91107f9ae42f96c060c310596db9aa869a8dbc..faad96f04af2e368f0276ade417dd1ba7841270b 100644
--- a/src/main/java/net/minecraft/server/level/ServerBossEvent.java
+++ b/src/main/java/net/minecraft/server/level/ServerBossEvent.java
@@ -13,7 +13,7 @@ import net.minecraft.util.Mth;
 import net.minecraft.world.BossEvent;
 
 public class ServerBossEvent extends BossEvent {
-    private final Set<ServerPlayer> players = Sets.newHashSet();
+    private final Set<ServerPlayer> players = Sets.newConcurrentHashSet(); // Leaf - petal - players can be removed in async tracking
     private final Set<ServerPlayer> unmodifiablePlayers = Collections.unmodifiableSet(this.players);
     public boolean visible = true;
 
diff --git a/src/main/java/net/minecraft/server/level/ServerEntity.java b/src/main/java/net/minecraft/server/level/ServerEntity.java
index 05125144ce0cb50fa6ac769fa025cda010c93f14..2a020344039a85010283b12e6a8d1ad47f58a490 100644
--- a/src/main/java/net/minecraft/server/level/ServerEntity.java
+++ b/src/main/java/net/minecraft/server/level/ServerEntity.java
@@ -336,7 +336,11 @@ public class ServerEntity {
 
     public void removePairing(ServerPlayer player) {
         this.entity.stopSeenByPlayer(player);
-        player.connection.send(new ClientboundRemoveEntitiesPacket(new int[]{this.entity.getId()}));
+        // Leaf start - petal - ensure main thread
+        ((ServerLevel) this.entity.level()).chunkSource.chunkMap.runOnTrackerMainThread(() ->
+            player.connection.send(new ClientboundRemoveEntitiesPacket(this.entity.getId()))
+        );
+        // Leaf end - petal
     }
 
     public void addPairing(ServerPlayer player) {
@@ -344,7 +348,7 @@ public class ServerEntity {
 
         Objects.requireNonNull(list);
         this.sendPairingData(player, list::add);
-        player.connection.send(new ClientboundBundlePacket(list));
+        ((ServerLevel) this.entity.level()).chunkSource.chunkMap.runOnTrackerMainThread(() -> player.connection.send(new ClientboundBundlePacket(list))); // Leaf - petal - Main thread
         this.entity.startSeenByPlayer(player);
     }
 
@@ -464,19 +468,28 @@ public class ServerEntity {
 
         if (list != null) {
             this.trackedDataValues = datawatcher.getNonDefaultValues();
-            this.broadcastAndSend(new ClientboundSetEntityDataPacket(this.entity.getId(), list));
+            // Leaf start - petal - sync
+            ((ServerLevel) this.entity.level()).chunkSource.chunkMap.runOnTrackerMainThread(() ->
+                    this.broadcastAndSend(new ClientboundSetEntityDataPacket(this.entity.getId(), list))
+            );
+            // Leaf end - petal - sync
         }
 
         if (this.entity instanceof LivingEntity) {
             Set<AttributeInstance> set = ((LivingEntity) this.entity).getAttributes().getAttributesToSync();
 
             if (!set.isEmpty()) {
+                // Leaf start - petal - sync
+                final Set<AttributeInstance> copy = new it.unimi.dsi.fastutil.objects.ObjectOpenHashSet<>(set);
+                ((ServerLevel) this.entity.level()).chunkSource.chunkMap.runOnTrackerMainThread(() -> {
                 // CraftBukkit start - Send scaled max health
                 if (this.entity instanceof ServerPlayer) {
-                    ((ServerPlayer) this.entity).getBukkitEntity().injectScaledMaxHealth(set, false);
+                    ((ServerPlayer) this.entity).getBukkitEntity().injectScaledMaxHealth(copy, false);
                 }
                 // CraftBukkit end
-                this.broadcastAndSend(new ClientboundUpdateAttributesPacket(this.entity.getId(), set));
+                this.broadcastAndSend(new ClientboundUpdateAttributesPacket(this.entity.getId(), copy));
+                });
+                // Leaf end - petal - sync
             }
 
             set.clear();
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 946339933b361f5a85df74d6c212acffe2e08f5e..bf1285c718ec326ea2c9f6dbbbfdff8b9ddcd7b6 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -2399,7 +2399,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
 
     @Override
     public LevelEntityGetter<Entity> getEntities() {
-        org.spigotmc.AsyncCatcher.catchOp("Chunk getEntities call"); // Spigot
+        //org.spigotmc.AsyncCatcher.catchOp("Chunk getEntities call"); // Spigot // Leaf - petal
         return this.moonrise$getEntityLookup(); // Paper - rewrite chunk system
     }
 
diff --git a/src/main/java/org/dreeam/leaf/async/tracker/MultithreadedTracker.java b/src/main/java/org/dreeam/leaf/async/tracker/MultithreadedTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..2679d61a82fd657bce71fbaf350d99f675fa985e
--- /dev/null
+++ b/src/main/java/org/dreeam/leaf/async/tracker/MultithreadedTracker.java
@@ -0,0 +1,28 @@
+package org.dreeam.leaf.async.tracker;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+public class MultithreadedTracker {
+
+    private static final Executor trackerExecutor = new ThreadPoolExecutor(
+            1,
+            org.dreeam.leaf.config.modules.async.MultithreadedTracker.asyncEntityTrackerMaxThreads,
+            org.dreeam.leaf.config.modules.async.MultithreadedTracker.asyncEntityTrackerKeepalive, TimeUnit.SECONDS,
+            new LinkedBlockingQueue<>(),
+            new ThreadFactoryBuilder()
+                    .setNameFormat("leaf-async-tracker-thread-%d")
+                    .setPriority(Thread.NORM_PRIORITY - 2)
+                    .build());
+
+    private MultithreadedTracker() {
+    }
+
+    public static void tick(Runnable runnable) {
+        trackerExecutor.execute(runnable);
+    }
+}
diff --git a/src/main/java/org/dreeam/leaf/config/modules/async/MultithreadedTracker.java b/src/main/java/org/dreeam/leaf/config/modules/async/MultithreadedTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..ef9d4587d9ca640eb1b2fd9f47e7e5411af7719f
--- /dev/null
+++ b/src/main/java/org/dreeam/leaf/config/modules/async/MultithreadedTracker.java
@@ -0,0 +1,36 @@
+package org.dreeam.leaf.config.modules.async;
+
+import org.dreeam.leaf.config.ConfigModules;
+import org.dreeam.leaf.config.EnumConfigCategory;
+import org.dreeam.leaf.config.LeafConfig;
+
+public class MultithreadedTracker extends ConfigModules {
+
+    public String getBasePath() {
+        return EnumConfigCategory.ASYNC.getBaseKeyName() + ".async-entity-tracker";
+    }
+
+    public static boolean enabled = true;
+    public static int asyncEntityTrackerMaxThreads = 0;
+    public static int asyncEntityTrackerKeepalive = 60;
+
+    @Override
+    public void onLoaded() {
+        config.addComment(getBasePath(), """
+                Make entity tracking async.
+                Active testing, report if you encountr issues""");
+
+        enabled = config().getBoolean(getBasePath() + ".enabled", enabled);
+        asyncEntityTrackerMaxThreads = config.getInt(getBasePath() + ".max-threads", asyncEntityTrackerMaxThreads);
+        asyncEntityTrackerKeepalive = config.getInt(getBasePath() + ".keepalive", asyncEntityTrackerKeepalive);
+
+        if (asyncEntityTrackerMaxThreads < 0)
+            asyncEntityTrackerMaxThreads = Math.max(Runtime.getRuntime().availableProcessors() + asyncEntityTrackerMaxThreads, 1);
+        else if (asyncEntityTrackerMaxThreads == 0)
+            asyncEntityTrackerMaxThreads = Math.max(Runtime.getRuntime().availableProcessors() / 4, 1);
+        if (!enabled)
+            asyncEntityTrackerMaxThreads = 0;
+        else
+            LeafConfig.LOGGER.info("Using {} threads for Async Entity Tracker", asyncEntityTrackerMaxThreads);
+    }
+}
