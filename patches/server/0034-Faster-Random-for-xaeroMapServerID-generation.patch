From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dreeam <61569423+Dreeam-qwq@users.noreply.github.com>
Date: Mon, 9 Oct 2023 21:33:08 -0400
Subject: [PATCH] Faster Random for xaeroMapServerID generation


diff --git a/src/main/java/org/dreeam/leaf/LeafConfig.java b/src/main/java/org/dreeam/leaf/LeafConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..4974ba174afe8cfd30e4dbbd59d4e88f62f45380
--- /dev/null
+++ b/src/main/java/org/dreeam/leaf/LeafConfig.java
@@ -0,0 +1,296 @@
+package org.dreeam.leaf;
+
+import com.google.common.collect.ImmutableMap;
+import net.minecraft.core.registries.BuiltInRegistries;
+import java.util.concurrent.ThreadLocalRandom;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.entity.EntityType;
+import org.bukkit.Bukkit;
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.MemoryConfiguration;
+import org.jetbrains.annotations.Nullable;
+import org.simpleyaml.configuration.comments.CommentType;
+import org.simpleyaml.configuration.file.YamlFile;
+import org.simpleyaml.exceptions.InvalidConfigurationException;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.Collections;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Random;
+import java.util.logging.Level;
+
+public class LeafConfig {
+
+    private static final YamlFile config = new YamlFile();
+    private static int updates = 0;
+
+    private static ConfigurationSection convertToBukkit(org.simpleyaml.configuration.ConfigurationSection section) {
+        ConfigurationSection newSection = new MemoryConfiguration();
+        for (String key : section.getKeys(false)) {
+            if (section.isConfigurationSection(key)) {
+                newSection.set(key, convertToBukkit(section.getConfigurationSection(key)));
+            } else {
+                newSection.set(key, section.get(key));
+            }
+        }
+        return newSection;
+    }
+
+    public static ConfigurationSection getConfigCopy() {
+        return convertToBukkit(config);
+    }
+
+    public static int getUpdates() {
+        return updates;
+    }
+
+    public static void load() throws IOException {
+        File configFile = new File("leaf.yml");
+
+        if (configFile.exists()) {
+            try {
+                config.load(configFile);
+            } catch (InvalidConfigurationException e) {
+                throw new IOException(e);
+            }
+        }
+
+        getString("info.version", "1.2");
+        setComment("info",
+                "Leaf Config",
+                "Github Repo: https://github.com/Winds-Studio/Leaf",
+                "Discord: dreeam___ | QQ: 2682173972");
+
+        for (Method method : LeafConfig.class.getDeclaredMethods()) {
+            if (Modifier.isStatic(method.getModifiers()) && Modifier.isPrivate(method.getModifiers()) && method.getParameterCount() == 0 &&
+                    method.getReturnType() == Void.TYPE && !method.getName().startsWith("lambda")) {
+                method.setAccessible(true);
+                try {
+                    method.invoke(null);
+                } catch (Throwable t) {
+                    MinecraftServer.LOGGER.warn("Failed to load configuration option from " + method.getName(), t);
+                }
+            }
+        }
+
+        updates++;
+
+        config.save(configFile);
+
+    }
+
+    private static void setComment(String key, String... comment) {
+        if (config.contains(key)) {
+            config.setComment(key, String.join("\n", comment), CommentType.BLOCK);
+        }
+    }
+
+    private static void ensureDefault(String key, Object defaultValue, String... comment) {
+        if (!config.contains(key)) {
+            config.set(key, defaultValue);
+            config.setComment(key, String.join("\n", comment), CommentType.BLOCK);
+        }
+    }
+
+    private static void set(String key, Object defaultValue) {
+        config.addDefault(key, defaultValue);
+        config.set(key, defaultValue);
+    }
+
+    private static boolean getBoolean(String key, boolean defaultValue, String... comment) {
+        return getBoolean(key, null, defaultValue, comment);
+    }
+
+    private static boolean getBoolean(String key, @Nullable String oldKey, boolean defaultValue, String... comment) {
+        ensureDefault(key, defaultValue, comment);
+        return config.getBoolean(key, defaultValue);
+    }
+
+    private static int getInt(String key, int defaultValue, String... comment) {
+        return getInt(key, null, defaultValue, comment);
+    }
+
+    private static int getInt(String key, @Nullable String oldKey, int defaultValue, String... comment) {
+        ensureDefault(key, defaultValue, comment);
+        return config.getInt(key, defaultValue);
+    }
+
+    private static double getDouble(String key, double defaultValue, String... comment) {
+        return getDouble(key, null, defaultValue, comment);
+    }
+
+    private static double getDouble(String key, @Nullable String oldKey, double defaultValue, String... comment) {
+        ensureDefault(key, defaultValue, comment);
+        return config.getDouble(key, defaultValue);
+    }
+
+    private static String getString(String key, String defaultValue, String... comment) {
+        return getOldString(key, null, defaultValue, comment);
+    }
+
+    private static String getOldString(String key, @Nullable String oldKey, String defaultValue, String... comment) {
+        ensureDefault(key, defaultValue, comment);
+        return config.getString(key, defaultValue);
+    }
+
+    private static List<String> getStringList(String key, List<String> defaultValue, String... comment) {
+        return getStringList(key, null, defaultValue, comment);
+    }
+
+    private static List<String> getStringList(String key, @Nullable String oldKey, List<String> defaultValue, String... comment) {
+        ensureDefault(key, defaultValue, comment);
+        return config.getStringList(key);
+    }
+
+    static Map<String, Object> getMap(String key, Map<String, Object> defaultValue) {
+        if (defaultValue != null && getConfigCopy().getConfigurationSection(key) == null) {
+            config.addDefault(key, defaultValue);
+            return defaultValue;
+        }
+        return toMap(getConfigCopy().getConfigurationSection(key));
+    }
+
+    private static Map<String, Object> toMap(ConfigurationSection section) {
+        ImmutableMap.Builder<String, Object> builder = ImmutableMap.builder();
+        if (section != null) {
+            for (String key : section.getKeys(false)) {
+                Object obj = section.get(key);
+                if (obj != null) {
+                    builder.put(key, obj instanceof ConfigurationSection val ? toMap(val) : obj);
+                }
+            }
+        }
+        return builder.build();
+    }
+
+    public static String serverModName = "Leaf";
+    private static void serverModName() {
+        serverModName = getString("server-mod-name", serverModName);
+    }
+
+    public static String serverGUIName = "Leaf Console";
+    private static void serverGUIName() {
+        serverGUIName = getString("server-gui-name", serverGUIName);
+    }
+
+    public static boolean removeMojangUsernameCheck = true;
+    public static boolean removeSpigotCheckBungeeConfig = true;
+    public static boolean removeUseItemOnPacketTooFar = false;
+    public static double maxUseItemDistance = 1.0000001D;
+    private static void removal() {
+        removeMojangUsernameCheck = getBoolean("remove-Mojang-username-check", removeMojangUsernameCheck,
+                "Remove username check of Mojang",
+                "enabling all characters as username");
+        removeSpigotCheckBungeeConfig = getBoolean("remove-Spigot-check-bungee-config", removeSpigotCheckBungeeConfig,
+                "Enable player enter backend server through proxy",
+                "without backend server enabling its bungee mode");
+        removeUseItemOnPacketTooFar = getBoolean("remove-UseItemOnPacket-too-far-check", removeUseItemOnPacketTooFar,
+                "To enable this, players can use some packet modules with hack clients and the NoCom Exploit!!");
+        maxUseItemDistance = getDouble("max-UseItem-distance", maxUseItemDistance, "The max distance of UseItem for players");
+    }
+
+    public static boolean enableAsyncMobSpawning = true;
+    public static boolean asyncMobSpawningInitialized;
+    public static boolean dabEnabled = true;
+    public static int startDistance = 12;
+    public static int startDistanceSquared;
+    public static int maximumActivationPrio = 20;
+    public static int activationDistanceMod = 8;
+    public static boolean throttleInactiveGoalSelectorTick = true;
+    public static Map<String, Integer> projectileTimeouts;
+    public static boolean useSpigotItemMergingMechanism = true;
+    public static boolean asyncPathfinding = false;
+    public static int asyncPathfindingMaxThreads = 0;
+    public static int asyncPathfindingKeepalive = 60;
+    public static boolean cacheMinecartCollision = false;
+    private static void performance() {
+        boolean asyncMobSpawning = getBoolean("performance.enable-async-mob-spawning", enableAsyncMobSpawning,
+                "Whether or not asynchronous mob spawning should be enabled.",
+                "On servers with many entities, this can improve performance by up to 15%. You must have",
+                "paper's per-player-mob-spawns setting set to true for this to work.",
+                "One quick note - this does not actually spawn mobs async (that would be very unsafe).",
+                "This just offloads some expensive calculations that are required for mob spawning.");
+        // This prevents us from changing the value during a reload.
+        if (!asyncMobSpawningInitialized) {
+            asyncMobSpawningInitialized = true;
+            enableAsyncMobSpawning = asyncMobSpawning;
+        }
+        dabEnabled = getBoolean("performance.dab.enabled", "dab.enabled", dabEnabled);
+        startDistance = getInt("performance.dab.start-distance", "dab.start-distance", startDistance,
+                "This value determines how far away an entity has to be",
+                "from the player to start being effected by DEAR.");
+        startDistanceSquared = startDistance * startDistance;
+        maximumActivationPrio = getInt("performance.dab.max-tick-freq", "dab.max-tick-freq", maximumActivationPrio,
+                "This value defines how often in ticks, the furthest entity",
+                "will get their pathfinders and behaviors ticked. 20 = 1s");
+        activationDistanceMod = getInt("performance.dab.activation-dist-mod", "dab.activation-dist-mod", activationDistanceMod,
+                "This value defines how much distance modifies an entity's",
+                "tick frequency. freq = (distanceToPlayer^2) / (2^value)",
+                "If you want further away entities to tick less often, use 7.",
+                "If you want further away entities to tick more often, try 9.");
+        for (EntityType<?> entityType : BuiltInRegistries.ENTITY_TYPE) {
+            entityType.dabEnabled = true; // reset all, before setting the ones to true
+        }
+        getStringList("performance.dab.blacklisted-entities", "dab.blacklisted-entities", Collections.emptyList(), "A list of entities to ignore for activation")
+                .forEach(name -> EntityType.byString(name).ifPresentOrElse(entityType -> {
+                    entityType.dabEnabled = false;
+                }, () -> MinecraftServer.LOGGER.warn("Unknown entity \"" + name + "\"")));
+        setComment("performance.dab", "Optimizes entity brains when", "they're far away from the player");
+        throttleInactiveGoalSelectorTick = getBoolean("performance.inactive-goal-selector-throttle", "inactive-goal-selector-throttle", throttleInactiveGoalSelectorTick,
+                "Throttles the AI goal selector in entity inactive ticks.",
+                "This can improve performance by a few percent, but has minor gameplay implications.");
+        // Set some defaults
+        getInt("performance.entity_timeouts.SNOWBALL", -1);
+        getInt("performance.entity_timeouts.LLAMA_SPIT", -1);
+        setComment("entity_timeouts",
+                "These values define a entity's maximum lifespan. If an",
+                "entity is in this list and it has survived for longer than",
+                "that number of ticks, then it will be removed. Setting a value to",
+                "-1 disables this feature.");
+        for (EntityType<?> entityType : BuiltInRegistries.ENTITY_TYPE) {
+            String type = EntityType.getKey(entityType).getPath().toUpperCase(Locale.ROOT);
+            entityType.ttl = config.getInt("entity_timeouts." + type, -1);
+        }
+        useSpigotItemMergingMechanism = getBoolean("performance.use-spigot-item-merging-mechanism", useSpigotItemMergingMechanism);
+        asyncPathfinding = getBoolean("performance.async-pathfinding.enable", asyncPathfinding);
+        asyncPathfindingMaxThreads = getInt("performance.async-pathfinding.max-threads", asyncPathfindingMaxThreads);
+        asyncPathfindingKeepalive = getInt("performance.async-pathfinding.keepalive", asyncPathfindingKeepalive);
+        if (asyncPathfindingMaxThreads < 0)
+            asyncPathfindingMaxThreads = Math.max(Runtime.getRuntime().availableProcessors() + asyncPathfindingMaxThreads, 1);
+        else if (asyncPathfindingMaxThreads == 0)
+            asyncPathfindingMaxThreads = Math.max(Runtime.getRuntime().availableProcessors() / 4, 1);
+        if (!asyncPathfinding)
+            asyncPathfindingMaxThreads = 0;
+        else
+            Bukkit.getLogger().log(Level.INFO, "Using " + asyncPathfindingMaxThreads + " threads for Async Pathfinding");
+        cacheMinecartCollision = getBoolean("performance.cache-minecart-collision", cacheMinecartCollision,
+                "Cache the minecart collision result to prevent massive stacked minecart lag the server.",
+                "The known issue: entity can't enter the minecart after enabling this!");
+    }
+
+    public static boolean jadeProtocol = false;
+    public static boolean appleskinProtocol = false;
+    public static boolean xaeroMapProtocol = false;
+    public static int xaeroMapServerID = ThreadLocalRandom.current().nextInt(); // Leaf - Faster Random
+    private static void network() {
+        jadeProtocol = getBoolean("network.protocol.jade-protocol", jadeProtocol);
+        appleskinProtocol = getBoolean("network.protocol.appleskin-protocol", appleskinProtocol);
+        xaeroMapProtocol = getBoolean("network.protocol.xaero-map-protocol", xaeroMapProtocol);
+        xaeroMapServerID = getInt("network.protocol.xaero-map-server-id", xaeroMapServerID);
+    }
+
+    public static String sentryDsn = "";
+    private static void sentryDsn() {
+        String sentryEnvironment = System.getenv("SENTRY_DSN");
+        String sentryConfig = getString("sentry-dsn", sentryDsn, "Sentry DSN for improved error logging, leave blank to disable", "Obtain from https://sentry.io/welcome/");
+        sentryDsn = sentryEnvironment == null ? sentryConfig : sentryEnvironment;
+        if (sentryDsn != null && !sentryDsn.isBlank()) {
+            gg.pufferfish.pufferfish.sentry.SentryManager.init();
+        }
+    }
+}
